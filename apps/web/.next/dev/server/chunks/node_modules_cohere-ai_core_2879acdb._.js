module.exports = [
"[project]/node_modules/cohere-ai/core/json.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toJson = void 0;
exports.fromJson = fromJson;
/**
 * Serialize a value to JSON
 * @param value A JavaScript value, usually an object or array, to be converted.
 * @param replacer A function that transforms the results.
 * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
 * @returns JSON string
 */ const toJson = (value, replacer, space)=>{
    return JSON.stringify(value, replacer, space);
};
exports.toJson = toJson;
/**
 * Parse JSON string to object, array, or other type
 * @param text A valid JSON string.
 * @param reviver A function that transforms the results. This function is called for each member of the object. If a member contains nested objects, the nested objects are transformed before the parent object is.
 * @returns Parsed object, array, or other type
 */ function fromJson(text, reviver) {
    return JSON.parse(text, reviver);
}
}),
"[project]/node_modules/cohere-ai/core/base64.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.base64Encode = base64Encode;
exports.base64Decode = base64Decode;
function base64ToBytes(base64) {
    const binString = atob(base64);
    return Uint8Array.from(binString, (m)=>m.codePointAt(0));
}
function bytesToBase64(bytes) {
    const binString = String.fromCodePoint(...bytes);
    return btoa(binString);
}
function base64Encode(input) {
    if (typeof Buffer !== "undefined") {
        return Buffer.from(input, "utf8").toString("base64");
    }
    const bytes = new TextEncoder().encode(input);
    return bytesToBase64(bytes);
}
function base64Decode(input) {
    if (typeof Buffer !== "undefined") {
        return Buffer.from(input, "base64").toString("utf8");
    }
    const bytes = base64ToBytes(input);
    return new TextDecoder().decode(bytes);
}
}),
"[project]/node_modules/cohere-ai/core/auth/BasicAuth.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BasicAuth = void 0;
const base64_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/base64.js [app-route] (ecmascript)");
const BASIC_AUTH_HEADER_PREFIX = /^Basic /i;
exports.BasicAuth = {
    toAuthorizationHeader: (basicAuth)=>{
        if (basicAuth == null) {
            return undefined;
        }
        const token = (0, base64_1.base64Encode)(`${basicAuth.username}:${basicAuth.password}`);
        return `Basic ${token}`;
    },
    fromAuthorizationHeader: (header)=>{
        const credentials = header.replace(BASIC_AUTH_HEADER_PREFIX, "");
        const decoded = (0, base64_1.base64Decode)(credentials);
        const [username, ...passwordParts] = decoded.split(":");
        const password = passwordParts.length > 0 ? passwordParts.join(":") : undefined;
        if (username == null || password == null) {
            throw new Error("Invalid basic auth");
        }
        return {
            username,
            password
        };
    }
};
}),
"[project]/node_modules/cohere-ai/core/auth/BearerToken.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BearerToken = void 0;
const BEARER_AUTH_HEADER_PREFIX = /^Bearer /i;
exports.BearerToken = {
    toAuthorizationHeader: (token)=>{
        if (token == null) {
            return undefined;
        }
        return `Bearer ${token}`;
    },
    fromAuthorizationHeader: (header)=>{
        return header.replace(BEARER_AUTH_HEADER_PREFIX, "").trim();
    }
};
}),
"[project]/node_modules/cohere-ai/core/auth/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BearerToken = exports.BasicAuth = void 0;
var BasicAuth_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/auth/BasicAuth.js [app-route] (ecmascript)");
Object.defineProperty(exports, "BasicAuth", {
    enumerable: true,
    get: function() {
        return BasicAuth_1.BasicAuth;
    }
});
var BearerToken_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/auth/BearerToken.js [app-route] (ecmascript)");
Object.defineProperty(exports, "BearerToken", {
    enumerable: true,
    get: function() {
        return BearerToken_1.BearerToken;
    }
});
}),
"[project]/node_modules/cohere-ai/core/fetcher/EndpointSupplier.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EndpointSupplier = void 0;
exports.EndpointSupplier = {
    get: (supplier, arg)=>__awaiter(void 0, void 0, void 0, function*() {
            if (typeof supplier === "function") {
                return supplier(arg);
            } else {
                return supplier;
            }
        })
};
}),
"[project]/node_modules/cohere-ai/core/logging/logger.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Logger = exports.ConsoleLogger = exports.LogLevel = void 0;
exports.createLogger = createLogger;
exports.LogLevel = {
    Debug: "debug",
    Info: "info",
    Warn: "warn",
    Error: "error"
};
const logLevelMap = {
    [exports.LogLevel.Debug]: 1,
    [exports.LogLevel.Info]: 2,
    [exports.LogLevel.Warn]: 3,
    [exports.LogLevel.Error]: 4
};
/**
 * Default console-based logger implementation.
 */ class ConsoleLogger {
    debug(message, ...args) {
        console.debug(message, ...args);
    }
    info(message, ...args) {
        console.info(message, ...args);
    }
    warn(message, ...args) {
        console.warn(message, ...args);
    }
    error(message, ...args) {
        console.error(message, ...args);
    }
}
exports.ConsoleLogger = ConsoleLogger;
/**
 * Logger class that provides level-based logging functionality.
 */ class Logger {
    /**
     * Creates a new logger instance.
     * @param config - Logger configuration
     */ constructor(config){
        this.level = logLevelMap[config.level];
        this.logger = config.logger;
        this.silent = config.silent;
    }
    /**
     * Checks if a log level should be output based on configuration.
     * @param level - The log level to check
     * @returns True if the level should be logged
     */ shouldLog(level) {
        return !this.silent && this.level <= logLevelMap[level];
    }
    /**
     * Checks if debug logging is enabled.
     * @returns True if debug logs should be output
     */ isDebug() {
        return this.shouldLog(exports.LogLevel.Debug);
    }
    /**
     * Logs a debug message if debug logging is enabled.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */ debug(message, ...args) {
        if (this.isDebug()) {
            this.logger.debug(message, ...args);
        }
    }
    /**
     * Checks if info logging is enabled.
     * @returns True if info logs should be output
     */ isInfo() {
        return this.shouldLog(exports.LogLevel.Info);
    }
    /**
     * Logs an info message if info logging is enabled.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */ info(message, ...args) {
        if (this.isInfo()) {
            this.logger.info(message, ...args);
        }
    }
    /**
     * Checks if warning logging is enabled.
     * @returns True if warning logs should be output
     */ isWarn() {
        return this.shouldLog(exports.LogLevel.Warn);
    }
    /**
     * Logs a warning message if warning logging is enabled.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */ warn(message, ...args) {
        if (this.isWarn()) {
            this.logger.warn(message, ...args);
        }
    }
    /**
     * Checks if error logging is enabled.
     * @returns True if error logs should be output
     */ isError() {
        return this.shouldLog(exports.LogLevel.Error);
    }
    /**
     * Logs an error message if error logging is enabled.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */ error(message, ...args) {
        if (this.isError()) {
            this.logger.error(message, ...args);
        }
    }
}
exports.Logger = Logger;
function createLogger(config) {
    var _a, _b, _c;
    if (config == null) {
        return defaultLogger;
    }
    if (config instanceof Logger) {
        return config;
    }
    config = config !== null && config !== void 0 ? config : {};
    (_a = config.level) !== null && _a !== void 0 ? _a : config.level = exports.LogLevel.Info;
    (_b = config.logger) !== null && _b !== void 0 ? _b : config.logger = new ConsoleLogger();
    (_c = config.silent) !== null && _c !== void 0 ? _c : config.silent = true;
    return new Logger(config);
}
const defaultLogger = new Logger({
    level: exports.LogLevel.Info,
    logger: new ConsoleLogger(),
    silent: true
});
}),
"[project]/node_modules/cohere-ai/core/url/qs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toQueryString = toQueryString;
const defaultQsOptions = {
    arrayFormat: "indices",
    encode: true
};
function encodeValue(value, shouldEncode) {
    if (value === undefined) {
        return "";
    }
    if (value === null) {
        return "";
    }
    const stringValue = String(value);
    return shouldEncode ? encodeURIComponent(stringValue) : stringValue;
}
function stringifyObject(obj, prefix = "", options) {
    const parts = [];
    for (const [key, value] of Object.entries(obj)){
        const fullKey = prefix ? `${prefix}[${key}]` : key;
        if (value === undefined) {
            continue;
        }
        if (Array.isArray(value)) {
            if (value.length === 0) {
                continue;
            }
            for(let i = 0; i < value.length; i++){
                const item = value[i];
                if (item === undefined) {
                    continue;
                }
                if (typeof item === "object" && !Array.isArray(item) && item !== null) {
                    const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i}]` : fullKey;
                    parts.push(...stringifyObject(item, arrayKey, options));
                } else {
                    const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i}]` : fullKey;
                    const encodedKey = options.encode ? encodeURIComponent(arrayKey) : arrayKey;
                    parts.push(`${encodedKey}=${encodeValue(item, options.encode)}`);
                }
            }
        } else if (typeof value === "object" && value !== null) {
            if (Object.keys(value).length === 0) {
                continue;
            }
            parts.push(...stringifyObject(value, fullKey, options));
        } else {
            const encodedKey = options.encode ? encodeURIComponent(fullKey) : fullKey;
            parts.push(`${encodedKey}=${encodeValue(value, options.encode)}`);
        }
    }
    return parts;
}
function toQueryString(obj, options) {
    if (obj == null || typeof obj !== "object") {
        return "";
    }
    const parts = stringifyObject(obj, "", Object.assign(Object.assign({}, defaultQsOptions), options));
    return parts.join("&");
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/createRequestUrl.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createRequestUrl = createRequestUrl;
const qs_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/url/qs.js [app-route] (ecmascript)");
function createRequestUrl(baseUrl, queryParameters) {
    const queryString = (0, qs_1.toQueryString)(queryParameters, {
        arrayFormat: "repeat"
    });
    return queryString ? `${baseUrl}?${queryString}` : baseUrl;
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/BinaryResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getBinaryResponse = getBinaryResponse;
function getBinaryResponse(response) {
    const binaryResponse = {
        get bodyUsed () {
            return response.bodyUsed;
        },
        stream: ()=>response.body,
        arrayBuffer: response.arrayBuffer.bind(response),
        blob: response.blob.bind(response)
    };
    if ("bytes" in response && typeof response.bytes === "function") {
        binaryResponse.bytes = response.bytes.bind(response);
    }
    return binaryResponse;
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/ResponseWithBody.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isResponseWithBody = isResponseWithBody;
function isResponseWithBody(response) {
    return response.body != null;
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/getResponseBody.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getResponseBody = getResponseBody;
const json_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/json.js [app-route] (ecmascript)");
const BinaryResponse_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/BinaryResponse.js [app-route] (ecmascript)");
const ResponseWithBody_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/ResponseWithBody.js [app-route] (ecmascript)");
function getResponseBody(response, responseType) {
    return __awaiter(this, void 0, void 0, function*() {
        if (!(0, ResponseWithBody_1.isResponseWithBody)(response)) {
            return undefined;
        }
        switch(responseType){
            case "binary-response":
                return (0, BinaryResponse_1.getBinaryResponse)(response);
            case "blob":
                return yield response.blob();
            case "arrayBuffer":
                return yield response.arrayBuffer();
            case "sse":
                return response.body;
            case "streaming":
                return response.body;
            case "text":
                return yield response.text();
        }
        // if responseType is "json" or not specified, try to parse as JSON
        const text = yield response.text();
        if (text.length > 0) {
            try {
                const responseBody = (0, json_1.fromJson)(text);
                return responseBody;
            } catch (_err) {
                return {
                    ok: false,
                    error: {
                        reason: "non-json",
                        statusCode: response.status,
                        rawBody: text
                    }
                };
            }
        }
        return undefined;
    });
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/getErrorResponseBody.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getErrorResponseBody = getErrorResponseBody;
const json_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/json.js [app-route] (ecmascript)");
const getResponseBody_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/getResponseBody.js [app-route] (ecmascript)");
function getErrorResponseBody(response) {
    return __awaiter(this, void 0, void 0, function*() {
        var _a, _b, _c;
        let contentType = (_a = response.headers.get("Content-Type")) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (contentType == null || contentType.length === 0) {
            return (0, getResponseBody_1.getResponseBody)(response);
        }
        if (contentType.indexOf(";") !== -1) {
            contentType = (_c = (_b = contentType.split(";")[0]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : "";
        }
        switch(contentType){
            case "application/hal+json":
            case "application/json":
            case "application/ld+json":
            case "application/problem+json":
            case "application/vnd.api+json":
            case "text/json":
                {
                    const text = yield response.text();
                    return text.length > 0 ? (0, json_1.fromJson)(text) : undefined;
                }
            default:
                if (contentType.startsWith("application/vnd.") && contentType.endsWith("+json")) {
                    const text = yield response.text();
                    return text.length > 0 ? (0, json_1.fromJson)(text) : undefined;
                }
                // Fallback to plain text if content type is not recognized
                // Even if no body is present, the response will be an empty string
                return yield response.text();
        }
    });
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/getFetchFn.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getFetchFn = getFetchFn;
function getFetchFn() {
    return __awaiter(this, void 0, void 0, function*() {
        return fetch;
    });
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/getRequestBody.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getRequestBody = getRequestBody;
const json_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/json.js [app-route] (ecmascript)");
const qs_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/url/qs.js [app-route] (ecmascript)");
function getRequestBody(_a) {
    return __awaiter(this, arguments, void 0, function*({ body, type }) {
        if (type === "form") {
            return (0, qs_1.toQueryString)(body, {
                arrayFormat: "repeat",
                encode: true
            });
        }
        if (type.includes("json")) {
            return (0, json_1.toJson)(body);
        } else {
            return body;
        }
    });
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/signals.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getTimeoutSignal = getTimeoutSignal;
exports.anySignal = anySignal;
const TIMEOUT = "timeout";
function getTimeoutSignal(timeoutMs) {
    const controller = new AbortController();
    const abortId = setTimeout(()=>controller.abort(TIMEOUT), timeoutMs);
    return {
        signal: controller.signal,
        abortId
    };
}
function anySignal(...args) {
    const signals = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
    const controller = new AbortController();
    for (const signal of signals){
        if (signal.aborted) {
            controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason);
            break;
        }
        signal.addEventListener("abort", ()=>controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason), {
            signal: controller.signal
        });
    }
    return controller.signal;
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/makeRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeRequest = void 0;
const signals_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/signals.js [app-route] (ecmascript)");
const makeRequest = (fetchFn, url, method, headers, requestBody, timeoutMs, abortSignal, withCredentials, duplex)=>__awaiter(void 0, void 0, void 0, function*() {
        const signals = [];
        let timeoutAbortId;
        if (timeoutMs != null) {
            const { signal, abortId } = (0, signals_1.getTimeoutSignal)(timeoutMs);
            timeoutAbortId = abortId;
            signals.push(signal);
        }
        if (abortSignal != null) {
            signals.push(abortSignal);
        }
        const newSignals = (0, signals_1.anySignal)(signals);
        const response = yield fetchFn(url, {
            method: method,
            headers,
            body: requestBody,
            signal: newSignals,
            credentials: withCredentials ? "include" : undefined,
            // @ts-ignore
            duplex
        });
        if (timeoutAbortId != null) {
            clearTimeout(timeoutAbortId);
        }
        return response;
    });
exports.makeRequest = makeRequest;
}),
"[project]/node_modules/cohere-ai/core/fetcher/Headers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Headers = void 0;
let Headers;
if (typeof globalThis.Headers !== "undefined") {
    exports.Headers = Headers = globalThis.Headers;
} else {
    exports.Headers = Headers = class Headers {
        constructor(init){
            this.headers = new Map();
            if (init) {
                if (init instanceof Headers) {
                    init.forEach((value, key)=>this.append(key, value));
                } else if (Array.isArray(init)) {
                    for (const [key, value] of init){
                        if (typeof key === "string" && typeof value === "string") {
                            this.append(key, value);
                        } else {
                            throw new TypeError("Each header entry must be a [string, string] tuple");
                        }
                    }
                } else {
                    for (const [key, value] of Object.entries(init)){
                        if (typeof value === "string") {
                            this.append(key, value);
                        } else {
                            throw new TypeError("Header values must be strings");
                        }
                    }
                }
            }
        }
        append(name, value) {
            const key = name.toLowerCase();
            const existing = this.headers.get(key) || [];
            this.headers.set(key, [
                ...existing,
                value
            ]);
        }
        delete(name) {
            const key = name.toLowerCase();
            this.headers.delete(key);
        }
        get(name) {
            const key = name.toLowerCase();
            const values = this.headers.get(key);
            return values ? values.join(", ") : null;
        }
        has(name) {
            const key = name.toLowerCase();
            return this.headers.has(key);
        }
        set(name, value) {
            const key = name.toLowerCase();
            this.headers.set(key, [
                value
            ]);
        }
        forEach(callbackfn, thisArg) {
            const boundCallback = thisArg ? callbackfn.bind(thisArg) : callbackfn;
            this.headers.forEach((values, key)=>boundCallback(values.join(", "), key, this));
        }
        getSetCookie() {
            return this.headers.get("set-cookie") || [];
        }
        *entries() {
            for (const [key, values] of this.headers.entries()){
                yield [
                    key,
                    values.join(", ")
                ];
            }
        }
        *keys() {
            yield* this.headers.keys();
        }
        *values() {
            for (const values of this.headers.values()){
                yield values.join(", ");
            }
        }
        [Symbol.iterator]() {
            return this.entries();
        }
    };
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/RawResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unknownRawResponse = exports.abortRawResponse = void 0;
exports.toRawResponse = toRawResponse;
const Headers_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/Headers.js [app-route] (ecmascript)");
/**
 * A raw response indicating that the request was aborted.
 */ exports.abortRawResponse = {
    headers: new Headers_1.Headers(),
    redirected: false,
    status: 499,
    statusText: "Client Closed Request",
    type: "error",
    url: ""
};
/**
 * A raw response indicating an unknown error.
 */ exports.unknownRawResponse = {
    headers: new Headers_1.Headers(),
    redirected: false,
    status: 0,
    statusText: "Unknown Error",
    type: "error",
    url: ""
};
/**
 * Converts a `RawResponse` object into a `RawResponse` by extracting its properties,
 * excluding the `body` and `bodyUsed` fields.
 *
 * @param response - The `RawResponse` object to convert.
 * @returns A `RawResponse` object containing the extracted properties of the input response.
 */ function toRawResponse(response) {
    return {
        headers: response.headers,
        redirected: response.redirected,
        status: response.status,
        statusText: response.statusText,
        type: response.type,
        url: response.url
    };
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/requestWithRetries.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.requestWithRetries = requestWithRetries;
const INITIAL_RETRY_DELAY = 1000; // in milliseconds
const MAX_RETRY_DELAY = 60000; // in milliseconds
const DEFAULT_MAX_RETRIES = 2;
const JITTER_FACTOR = 0.2; // 20% random jitter
function addPositiveJitter(delay) {
    const jitterMultiplier = 1 + Math.random() * JITTER_FACTOR;
    return delay * jitterMultiplier;
}
function addSymmetricJitter(delay) {
    const jitterMultiplier = 1 + (Math.random() - 0.5) * JITTER_FACTOR;
    return delay * jitterMultiplier;
}
function getRetryDelayFromHeaders(response, retryAttempt) {
    const retryAfter = response.headers.get("Retry-After");
    if (retryAfter) {
        const retryAfterSeconds = parseInt(retryAfter, 10);
        if (!Number.isNaN(retryAfterSeconds) && retryAfterSeconds > 0) {
            return Math.min(retryAfterSeconds * 1000, MAX_RETRY_DELAY);
        }
        const retryAfterDate = new Date(retryAfter);
        if (!Number.isNaN(retryAfterDate.getTime())) {
            const delay = retryAfterDate.getTime() - Date.now();
            if (delay > 0) {
                return Math.min(Math.max(delay, 0), MAX_RETRY_DELAY);
            }
        }
    }
    const rateLimitReset = response.headers.get("X-RateLimit-Reset");
    if (rateLimitReset) {
        const resetTime = parseInt(rateLimitReset, 10);
        if (!Number.isNaN(resetTime)) {
            const delay = resetTime * 1000 - Date.now();
            if (delay > 0) {
                return addPositiveJitter(Math.min(delay, MAX_RETRY_DELAY));
            }
        }
    }
    return addSymmetricJitter(Math.min(INITIAL_RETRY_DELAY * Math.pow(2, retryAttempt), MAX_RETRY_DELAY));
}
function requestWithRetries(requestFn_1) {
    return __awaiter(this, arguments, void 0, function*(requestFn, maxRetries = DEFAULT_MAX_RETRIES) {
        let response = yield requestFn();
        for(let i = 0; i < maxRetries; ++i){
            if ([
                408,
                429
            ].includes(response.status) || response.status >= 500) {
                const delay = getRetryDelayFromHeaders(response, i);
                yield new Promise((resolve)=>setTimeout(resolve, delay));
                response = yield requestFn();
            } else {
                break;
            }
        }
        return response;
    });
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/Fetcher.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetcher = void 0;
exports.fetcherImpl = fetcherImpl;
const json_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/json.js [app-route] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/logging/logger.js [app-route] (ecmascript)");
const createRequestUrl_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/createRequestUrl.js [app-route] (ecmascript)");
const EndpointSupplier_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/EndpointSupplier.js [app-route] (ecmascript)");
const getErrorResponseBody_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/getErrorResponseBody.js [app-route] (ecmascript)");
const getFetchFn_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/getFetchFn.js [app-route] (ecmascript)");
const getRequestBody_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/getRequestBody.js [app-route] (ecmascript)");
const getResponseBody_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/getResponseBody.js [app-route] (ecmascript)");
const makeRequest_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/makeRequest.js [app-route] (ecmascript)");
const RawResponse_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/RawResponse.js [app-route] (ecmascript)");
const requestWithRetries_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/requestWithRetries.js [app-route] (ecmascript)");
const SENSITIVE_HEADERS = new Set([
    "authorization",
    "www-authenticate",
    "x-api-key",
    "api-key",
    "apikey",
    "x-api-token",
    "x-auth-token",
    "auth-token",
    "cookie",
    "set-cookie",
    "proxy-authorization",
    "proxy-authenticate",
    "x-csrf-token",
    "x-xsrf-token",
    "x-session-token",
    "x-access-token"
]);
function redactHeaders(headers) {
    const filtered = {};
    for (const [key, value] of Object.entries(headers)){
        if (SENSITIVE_HEADERS.has(key.toLowerCase())) {
            filtered[key] = "[REDACTED]";
        } else {
            filtered[key] = value;
        }
    }
    return filtered;
}
const SENSITIVE_QUERY_PARAMS = new Set([
    "api_key",
    "api-key",
    "apikey",
    "token",
    "access_token",
    "access-token",
    "auth_token",
    "auth-token",
    "password",
    "passwd",
    "secret",
    "api_secret",
    "api-secret",
    "apisecret",
    "key",
    "session",
    "session_id",
    "session-id"
]);
function redactQueryParameters(queryParameters) {
    if (queryParameters == null) {
        return queryParameters;
    }
    const redacted = {};
    for (const [key, value] of Object.entries(queryParameters)){
        if (SENSITIVE_QUERY_PARAMS.has(key.toLowerCase())) {
            redacted[key] = "[REDACTED]";
        } else {
            redacted[key] = value;
        }
    }
    return redacted;
}
function redactUrl(url) {
    const protocolIndex = url.indexOf("://");
    if (protocolIndex === -1) return url;
    const afterProtocol = protocolIndex + 3;
    // Find the first delimiter that marks the end of the authority section
    const pathStart = url.indexOf("/", afterProtocol);
    let queryStart = url.indexOf("?", afterProtocol);
    let fragmentStart = url.indexOf("#", afterProtocol);
    const firstDelimiter = Math.min(pathStart === -1 ? url.length : pathStart, queryStart === -1 ? url.length : queryStart, fragmentStart === -1 ? url.length : fragmentStart);
    // Find the LAST @ before the delimiter (handles multiple @ in credentials)
    let atIndex = -1;
    for(let i = afterProtocol; i < firstDelimiter; i++){
        if (url[i] === "@") {
            atIndex = i;
        }
    }
    if (atIndex !== -1) {
        url = `${url.slice(0, afterProtocol)}[REDACTED]@${url.slice(atIndex + 1)}`;
    }
    // Recalculate queryStart since url might have changed
    queryStart = url.indexOf("?");
    if (queryStart === -1) return url;
    fragmentStart = url.indexOf("#", queryStart);
    const queryEnd = fragmentStart !== -1 ? fragmentStart : url.length;
    const queryString = url.slice(queryStart + 1, queryEnd);
    if (queryString.length === 0) return url;
    // FAST PATH: Quick check if any sensitive keywords present
    // Using indexOf is faster than regex for simple substring matching
    const lower = queryString.toLowerCase();
    const hasSensitive = lower.includes("token") || lower.includes("key") || lower.includes("password") || lower.includes("passwd") || lower.includes("secret") || lower.includes("session") || lower.includes("auth");
    if (!hasSensitive) {
        return url;
    }
    // SLOW PATH: Parse and redact
    const redactedParams = [];
    const params = queryString.split("&");
    for (const param of params){
        const equalIndex = param.indexOf("=");
        if (equalIndex === -1) {
            redactedParams.push(param);
            continue;
        }
        const key = param.slice(0, equalIndex);
        let shouldRedact = SENSITIVE_QUERY_PARAMS.has(key.toLowerCase());
        if (!shouldRedact && key.includes("%")) {
            try {
                const decodedKey = decodeURIComponent(key);
                shouldRedact = SENSITIVE_QUERY_PARAMS.has(decodedKey.toLowerCase());
            } catch (_a) {}
        }
        redactedParams.push(shouldRedact ? `${key}=[REDACTED]` : param);
    }
    return url.slice(0, queryStart + 1) + redactedParams.join("&") + url.slice(queryEnd);
}
function getHeaders(args) {
    return __awaiter(this, void 0, void 0, function*() {
        var _a;
        const newHeaders = {};
        if (args.body !== undefined && args.contentType != null) {
            newHeaders["Content-Type"] = args.contentType;
        }
        if (args.headers == null) {
            return newHeaders;
        }
        for (const [key, value] of Object.entries(args.headers)){
            const result = yield EndpointSupplier_1.EndpointSupplier.get(value, {
                endpointMetadata: (_a = args.endpointMetadata) !== null && _a !== void 0 ? _a : {}
            });
            if (typeof result === "string") {
                newHeaders[key] = result;
                continue;
            }
            if (result == null) {
                continue;
            }
            newHeaders[key] = `${result}`;
        }
        return newHeaders;
    });
}
function fetcherImpl(args) {
    return __awaiter(this, void 0, void 0, function*() {
        var _a, _b, _c;
        const url = (0, createRequestUrl_1.createRequestUrl)(args.url, args.queryParameters);
        const requestBody = yield (0, getRequestBody_1.getRequestBody)({
            body: args.body,
            type: (_a = args.requestType) !== null && _a !== void 0 ? _a : "other"
        });
        const fetchFn = (_b = args.fetchFn) !== null && _b !== void 0 ? _b : yield (0, getFetchFn_1.getFetchFn)();
        const headers = yield getHeaders(args);
        const logger = (0, logger_1.createLogger)(args.logging);
        if (logger.isDebug()) {
            const metadata = {
                method: args.method,
                url: redactUrl(url),
                headers: redactHeaders(headers),
                queryParameters: redactQueryParameters(args.queryParameters),
                hasBody: requestBody != null
            };
            logger.debug("Making HTTP request", metadata);
        }
        try {
            const response = yield (0, requestWithRetries_1.requestWithRetries)(()=>__awaiter(this, void 0, void 0, function*() {
                    return (0, makeRequest_1.makeRequest)(fetchFn, url, args.method, headers, requestBody, args.timeoutMs, args.abortSignal, args.withCredentials, args.duplex);
                }), args.maxRetries);
            if (response.status >= 200 && response.status < 400) {
                if (logger.isDebug()) {
                    const metadata = {
                        method: args.method,
                        url: redactUrl(url),
                        statusCode: response.status,
                        responseHeaders: redactHeaders(Object.fromEntries(response.headers.entries()))
                    };
                    logger.debug("HTTP request succeeded", metadata);
                }
                return {
                    ok: true,
                    body: yield (0, getResponseBody_1.getResponseBody)(response, args.responseType),
                    headers: response.headers,
                    rawResponse: (0, RawResponse_1.toRawResponse)(response)
                };
            } else {
                if (logger.isError()) {
                    const metadata = {
                        method: args.method,
                        url: redactUrl(url),
                        statusCode: response.status,
                        responseHeaders: redactHeaders(Object.fromEntries(response.headers.entries()))
                    };
                    logger.error("HTTP request failed with error status", metadata);
                }
                return {
                    ok: false,
                    error: {
                        reason: "status-code",
                        statusCode: response.status,
                        body: yield (0, getErrorResponseBody_1.getErrorResponseBody)(response)
                    },
                    rawResponse: (0, RawResponse_1.toRawResponse)(response)
                };
            }
        } catch (error) {
            if ((_c = args.abortSignal) === null || _c === void 0 ? void 0 : _c.aborted) {
                if (logger.isError()) {
                    const metadata = {
                        method: args.method,
                        url: redactUrl(url)
                    };
                    logger.error("HTTP request was aborted", metadata);
                }
                return {
                    ok: false,
                    error: {
                        reason: "unknown",
                        errorMessage: "The user aborted a request"
                    },
                    rawResponse: RawResponse_1.abortRawResponse
                };
            } else if (error instanceof Error && error.name === "AbortError") {
                if (logger.isError()) {
                    const metadata = {
                        method: args.method,
                        url: redactUrl(url),
                        timeoutMs: args.timeoutMs
                    };
                    logger.error("HTTP request timed out", metadata);
                }
                return {
                    ok: false,
                    error: {
                        reason: "timeout"
                    },
                    rawResponse: RawResponse_1.abortRawResponse
                };
            } else if (error instanceof Error) {
                if (logger.isError()) {
                    const metadata = {
                        method: args.method,
                        url: redactUrl(url),
                        errorMessage: error.message
                    };
                    logger.error("HTTP request failed with error", metadata);
                }
                return {
                    ok: false,
                    error: {
                        reason: "unknown",
                        errorMessage: error.message
                    },
                    rawResponse: RawResponse_1.unknownRawResponse
                };
            }
            if (logger.isError()) {
                const metadata = {
                    method: args.method,
                    url: redactUrl(url),
                    error: (0, json_1.toJson)(error)
                };
                logger.error("HTTP request failed with unknown error", metadata);
            }
            return {
                ok: false,
                error: {
                    reason: "unknown",
                    errorMessage: (0, json_1.toJson)(error)
                },
                rawResponse: RawResponse_1.unknownRawResponse
            };
        }
    });
}
exports.fetcher = fetcherImpl;
}),
"[project]/node_modules/cohere-ai/core/fetcher/getHeader.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHeader = getHeader;
function getHeader(headers, header) {
    for (const [headerKey, headerValue] of Object.entries(headers)){
        if (headerKey.toLowerCase() === header.toLowerCase()) {
            return headerValue;
        }
    }
    return undefined;
}
}),
"[project]/node_modules/cohere-ai/core/fetcher/HttpResponsePromise.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpResponsePromise = void 0;
/**
 * A promise that returns the parsed response and lets you retrieve the raw response too.
 */ class HttpResponsePromise extends Promise {
    constructor(promise){
        // Initialize with a no-op to avoid premature parsing
        super((resolve)=>{
            resolve(undefined);
        });
        this.innerPromise = promise;
    }
    /**
     * Creates an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @param args - Arguments to pass to the function.
     * @returns An `HttpResponsePromise` instance.
     */ static fromFunction(fn, ...args) {
        return new HttpResponsePromise(fn(...args));
    }
    /**
     * Creates a function that returns an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @returns A function that returns an `HttpResponsePromise` instance.
     */ static interceptFunction(fn) {
        return (...args)=>{
            return HttpResponsePromise.fromPromise(fn(...args));
        };
    }
    /**
     * Creates an `HttpResponsePromise` from an existing promise.
     *
     * @param promise - A promise resolving to a `WithRawResponse` object.
     * @returns An `HttpResponsePromise` instance.
     */ static fromPromise(promise) {
        return new HttpResponsePromise(promise);
    }
    /**
     * Creates an `HttpResponsePromise` from an executor function.
     *
     * @param executor - A function that takes resolve and reject callbacks to create a promise.
     * @returns An `HttpResponsePromise` instance.
     */ static fromExecutor(executor) {
        const promise = new Promise(executor);
        return new HttpResponsePromise(promise);
    }
    /**
     * Creates an `HttpResponsePromise` from a resolved result.
     *
     * @param result - A `WithRawResponse` object to resolve immediately.
     * @returns An `HttpResponsePromise` instance.
     */ static fromResult(result) {
        const promise = Promise.resolve(result);
        return new HttpResponsePromise(promise);
    }
    unwrap() {
        if (!this.unwrappedPromise) {
            this.unwrappedPromise = this.innerPromise.then(({ data })=>data);
        }
        return this.unwrappedPromise;
    }
    /** @inheritdoc */ then(onfulfilled, onrejected) {
        return this.unwrap().then(onfulfilled, onrejected);
    }
    /** @inheritdoc */ catch(onrejected) {
        return this.unwrap().catch(onrejected);
    }
    /** @inheritdoc */ finally(onfinally) {
        return this.unwrap().finally(onfinally);
    }
    /**
     * Retrieves the data and raw response.
     *
     * @returns A promise resolving to a `WithRawResponse` object.
     */ withRawResponse() {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.innerPromise;
        });
    }
}
exports.HttpResponsePromise = HttpResponsePromise;
}),
"[project]/node_modules/cohere-ai/core/fetcher/Supplier.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Supplier = void 0;
exports.Supplier = {
    get: (supplier)=>__awaiter(void 0, void 0, void 0, function*() {
            if (typeof supplier === "function") {
                return supplier();
            } else {
                return supplier;
            }
        })
};
}),
"[project]/node_modules/cohere-ai/core/fetcher/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Supplier = exports.unknownRawResponse = exports.toRawResponse = exports.abortRawResponse = exports.HttpResponsePromise = exports.getHeader = exports.fetcher = exports.EndpointSupplier = void 0;
var EndpointSupplier_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/EndpointSupplier.js [app-route] (ecmascript)");
Object.defineProperty(exports, "EndpointSupplier", {
    enumerable: true,
    get: function() {
        return EndpointSupplier_1.EndpointSupplier;
    }
});
var Fetcher_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/Fetcher.js [app-route] (ecmascript)");
Object.defineProperty(exports, "fetcher", {
    enumerable: true,
    get: function() {
        return Fetcher_1.fetcher;
    }
});
var getHeader_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/getHeader.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getHeader", {
    enumerable: true,
    get: function() {
        return getHeader_1.getHeader;
    }
});
var HttpResponsePromise_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/HttpResponsePromise.js [app-route] (ecmascript)");
Object.defineProperty(exports, "HttpResponsePromise", {
    enumerable: true,
    get: function() {
        return HttpResponsePromise_1.HttpResponsePromise;
    }
});
var RawResponse_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/RawResponse.js [app-route] (ecmascript)");
Object.defineProperty(exports, "abortRawResponse", {
    enumerable: true,
    get: function() {
        return RawResponse_1.abortRawResponse;
    }
});
Object.defineProperty(exports, "toRawResponse", {
    enumerable: true,
    get: function() {
        return RawResponse_1.toRawResponse;
    }
});
Object.defineProperty(exports, "unknownRawResponse", {
    enumerable: true,
    get: function() {
        return RawResponse_1.unknownRawResponse;
    }
});
var Supplier_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/Supplier.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Supplier", {
    enumerable: true,
    get: function() {
        return Supplier_1.Supplier;
    }
});
}),
"[project]/node_modules/cohere-ai/core/file/file.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toBinaryUploadRequest = toBinaryUploadRequest;
exports.toMultipartDataPart = toMultipartDataPart;
function toBinaryUploadRequest(file) {
    return __awaiter(this, void 0, void 0, function*() {
        const { data, filename, contentLength, contentType } = yield getFileWithMetadata(file);
        const request = {
            body: data,
            headers: {}
        };
        if (filename) {
            request.headers["Content-Disposition"] = `attachment; filename="${filename}"`;
        }
        if (contentType) {
            request.headers["Content-Type"] = contentType;
        }
        if (contentLength != null) {
            request.headers["Content-Length"] = contentLength.toString();
        }
        return request;
    });
}
function toMultipartDataPart(file) {
    return __awaiter(this, void 0, void 0, function*() {
        const { data, filename, contentType } = yield getFileWithMetadata(file, {
            noSniffFileSize: true
        });
        return {
            data,
            filename,
            contentType
        };
    });
}
function getFileWithMetadata(file_1) {
    return __awaiter(this, arguments, void 0, function*(file, { noSniffFileSize } = {}) {
        var _a, _b, _c, _d, _e;
        if (isFileLike(file)) {
            return getFileWithMetadata({
                data: file
            }, {
                noSniffFileSize
            });
        }
        if ("path" in file) {
            const fs = yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)")));
            if (!fs || !fs.createReadStream) {
                throw new Error("File path uploads are not supported in this environment.");
            }
            const data = fs.createReadStream(file.path);
            const contentLength = (_a = file.contentLength) !== null && _a !== void 0 ? _a : noSniffFileSize === true ? undefined : yield tryGetFileSizeFromPath(file.path);
            const filename = (_b = file.filename) !== null && _b !== void 0 ? _b : getNameFromPath(file.path);
            return {
                data,
                filename,
                contentType: file.contentType,
                contentLength
            };
        }
        if ("data" in file) {
            const data = file.data;
            const contentLength = (_c = file.contentLength) !== null && _c !== void 0 ? _c : yield tryGetContentLengthFromFileLike(data, {
                noSniffFileSize
            });
            const filename = (_d = file.filename) !== null && _d !== void 0 ? _d : tryGetNameFromFileLike(data);
            return {
                data,
                filename,
                contentType: (_e = file.contentType) !== null && _e !== void 0 ? _e : tryGetContentTypeFromFileLike(data),
                contentLength
            };
        }
        throw new Error(`Invalid FileUpload of type ${typeof file}: ${JSON.stringify(file)}`);
    });
}
function isFileLike(value) {
    return isBuffer(value) || isArrayBufferView(value) || isArrayBuffer(value) || isUint8Array(value) || isBlob(value) || isFile(value) || isStreamLike(value) || isReadableStream(value);
}
function tryGetFileSizeFromPath(path) {
    return __awaiter(this, void 0, void 0, function*() {
        try {
            const fs = yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)")));
            if (!fs || !fs.promises || !fs.promises.stat) {
                return undefined;
            }
            const fileStat = yield fs.promises.stat(path);
            return fileStat.size;
        } catch (_fallbackError) {
            return undefined;
        }
    });
}
function tryGetNameFromFileLike(data) {
    if (isNamedValue(data)) {
        return data.name;
    }
    if (isPathedValue(data)) {
        return getNameFromPath(data.path.toString());
    }
    return undefined;
}
function tryGetContentLengthFromFileLike(data_1) {
    return __awaiter(this, arguments, void 0, function*(data, { noSniffFileSize } = {}) {
        if (isBuffer(data)) {
            return data.length;
        }
        if (isArrayBufferView(data)) {
            return data.byteLength;
        }
        if (isArrayBuffer(data)) {
            return data.byteLength;
        }
        if (isBlob(data)) {
            return data.size;
        }
        if (isFile(data)) {
            return data.size;
        }
        if (noSniffFileSize === true) {
            return undefined;
        }
        if (isPathedValue(data)) {
            return yield tryGetFileSizeFromPath(data.path.toString());
        }
        return undefined;
    });
}
function tryGetContentTypeFromFileLike(data) {
    if (isBlob(data)) {
        return data.type;
    }
    if (isFile(data)) {
        return data.type;
    }
    return undefined;
}
function getNameFromPath(path) {
    const lastForwardSlash = path.lastIndexOf("/");
    const lastBackSlash = path.lastIndexOf("\\");
    const lastSlashIndex = Math.max(lastForwardSlash, lastBackSlash);
    return lastSlashIndex >= 0 ? path.substring(lastSlashIndex + 1) : path;
}
function isNamedValue(value) {
    return typeof value === "object" && value != null && "name" in value;
}
function isPathedValue(value) {
    return typeof value === "object" && value != null && "path" in value;
}
function isStreamLike(value) {
    return typeof value === "object" && value != null && ("read" in value || "pipe" in value);
}
function isReadableStream(value) {
    return typeof value === "object" && value != null && "getReader" in value;
}
function isBuffer(value) {
    return typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(value);
}
function isArrayBufferView(value) {
    return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
}
function isArrayBuffer(value) {
    return typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer;
}
function isUint8Array(value) {
    return typeof Uint8Array !== "undefined" && value instanceof Uint8Array;
}
function isBlob(value) {
    return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFile(value) {
    return typeof File !== "undefined" && value instanceof File;
}
}),
"[project]/node_modules/cohere-ai/core/file/types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/cohere-ai/core/file/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/file/file.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/file/types.js [app-route] (ecmascript)"), exports);
}),
"[project]/node_modules/cohere-ai/core/form-data-utils/encodeAsFormParameter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeAsFormParameter = encodeAsFormParameter;
const qs_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/url/qs.js [app-route] (ecmascript)");
function encodeAsFormParameter(value) {
    const stringified = (0, qs_1.toQueryString)(value, {
        encode: false
    });
    const keyValuePairs = stringified.split("&").map((pair)=>{
        const [key, value] = pair.split("=");
        return [
            key,
            value
        ];
    });
    return Object.fromEntries(keyValuePairs);
}
}),
"[project]/node_modules/cohere-ai/core/runtime/runtime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RUNTIME = void 0;
/**
 * A constant that indicates which environment and version the SDK is running in.
 */ exports.RUNTIME = evaluateRuntime();
function evaluateRuntime() {
    var _a, _b, _c, _d, _e;
    /**
     * A constant that indicates whether the environment the code is running is a Web Browser.
     */ const isBrowser = ("TURBOPACK compile-time value", "undefined") !== "undefined" && typeof window.document !== "undefined";
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    /**
     * A constant that indicates whether the environment the code is running is Cloudflare.
     * https://developers.cloudflare.com/workers/runtime-apis/web-standards/#navigatoruseragent
     */ const isCloudflare = typeof globalThis !== "undefined" && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === "Cloudflare-Workers";
    if (isCloudflare) {
        return {
            type: "workerd"
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Edge Runtime.
     * https://vercel.com/docs/functions/runtimes/edge-runtime#check-if-you're-running-on-the-edge-runtime
     */ const isEdgeRuntime = typeof EdgeRuntime === "string";
    if (isEdgeRuntime) {
        return {
            type: "edge-runtime"
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is a Web Worker.
     */ const isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "DedicatedWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "ServiceWorkerGlobalScope" || ((_d = self.constructor) === null || _d === void 0 ? void 0 : _d.name) === "SharedWorkerGlobalScope");
    if (isWebWorker) {
        return {
            type: "web-worker"
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Deno.
     * FYI Deno spoofs process.versions.node, see https://deno.land/std@0.177.0/node/process.ts?s=versions
     */ const isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    if (isDeno) {
        return {
            type: "deno",
            version: Deno.version.deno
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Bun.sh.
     */ const isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    if (isBun) {
        return {
            type: "bun",
            version: Bun.version
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Node.JS.
     */ const isNode = typeof process !== "undefined" && "version" in process && !!process.version && "versions" in process && !!((_e = process.versions) === null || _e === void 0 ? void 0 : _e.node);
    if (isNode) {
        return {
            type: "node",
            version: process.versions.node,
            parsedVersion: Number(process.versions.node.split(".")[0])
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is in React-Native.
     * https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js
     */ const isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
    if (isReactNative) {
        return {
            type: "react-native"
        };
    }
    return {
        type: "unknown"
    };
}
}),
"[project]/node_modules/cohere-ai/core/runtime/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RUNTIME = void 0;
var runtime_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/runtime/runtime.js [app-route] (ecmascript)");
Object.defineProperty(exports, "RUNTIME", {
    enumerable: true,
    get: function() {
        return runtime_1.RUNTIME;
    }
});
}),
"[project]/node_modules/cohere-ai/core/form-data-utils/FormDataWrapper.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebFormData = exports.Node16FormData = exports.Node18FormData = void 0;
exports.newFormData = newFormData;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/runtime/index.js [app-route] (ecmascript)");
function isNamedValue(value) {
    return typeof value === "object" && value != null && "name" in value;
}
function newFormData() {
    return __awaiter(this, void 0, void 0, function*() {
        let formdata;
        if (runtime_1.RUNTIME.type === "node" && runtime_1.RUNTIME.parsedVersion != null && runtime_1.RUNTIME.parsedVersion >= 18) {
            formdata = new Node18FormData();
        } else if (runtime_1.RUNTIME.type === "node") {
            formdata = new Node16FormData();
        } else {
            formdata = new WebFormData();
        }
        yield formdata.setup();
        return formdata;
    });
}
/**
 * Form Data Implementation for Node.js 18+
 */ class Node18FormData {
    setup() {
        return __awaiter(this, void 0, void 0, function*() {
            this.fd = new (yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/node_modules/formdata-node/lib/form-data.cjs [app-route] (ecmascript)")))).FormData();
        });
    }
    append(key, value) {
        var _a;
        (_a = this.fd) === null || _a === void 0 ? void 0 : _a.append(key, value);
    }
    appendFile(key, value, fileName) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a, _b;
            if (fileName == null && isNamedValue(value)) {
                fileName = value.name;
            }
            if (value instanceof (yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/readable-stream/lib/ours/index.js [app-route] (ecmascript)")))).Readable) {
                (_a = this.fd) === null || _a === void 0 ? void 0 : _a.append(key, {
                    type: undefined,
                    name: fileName,
                    [Symbol.toStringTag]: "File",
                    stream () {
                        return value;
                    }
                });
            } else {
                (_b = this.fd) === null || _b === void 0 ? void 0 : _b.append(key, value, fileName);
            }
        });
    }
    getRequest() {
        return __awaiter(this, void 0, void 0, function*() {
            const encoder = new (yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/node_modules/form-data-encoder/lib/index.cjs [app-route] (ecmascript)")))).FormDataEncoder(this.fd);
            return {
                body: yield (yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/readable-stream/lib/ours/index.js [app-route] (ecmascript)")))).Readable.from(encoder),
                headers: encoder.headers,
                duplex: "half"
            };
        });
    }
}
exports.Node18FormData = Node18FormData;
/**
 * Form Data Implementation for Node.js 16-18
 */ class Node16FormData {
    setup() {
        return __awaiter(this, void 0, void 0, function*() {
            this.fd = new (yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/form-data/lib/form_data.js [app-route] (ecmascript)")))).default();
        });
    }
    append(key, value) {
        var _a;
        (_a = this.fd) === null || _a === void 0 ? void 0 : _a.append(key, value);
    }
    appendFile(key, value, fileName) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a, _b;
            if (fileName == null && isNamedValue(value)) {
                fileName = value.name;
            }
            let bufferedValue;
            if (!(value instanceof (yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/readable-stream/lib/ours/index.js [app-route] (ecmascript)")))).Readable)) {
                bufferedValue = Buffer.from((yield value.arrayBuffer()));
            } else {
                bufferedValue = value;
            }
            if (fileName == null) {
                (_a = this.fd) === null || _a === void 0 ? void 0 : _a.append(key, bufferedValue);
            } else {
                (_b = this.fd) === null || _b === void 0 ? void 0 : _b.append(key, bufferedValue, {
                    filename: fileName
                });
            }
        });
    }
    getRequest() {
        return {
            body: this.fd,
            headers: this.fd ? this.fd.getHeaders() : {}
        };
    }
}
exports.Node16FormData = Node16FormData;
/**
 * Form Data Implementation for Web
 */ class WebFormData {
    setup() {
        return __awaiter(this, void 0, void 0, function*() {
            this.fd = new FormData();
        });
    }
    append(key, value) {
        var _a;
        (_a = this.fd) === null || _a === void 0 ? void 0 : _a.append(key, value);
    }
    appendFile(key, value, fileName) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a;
            if (fileName == null && isNamedValue(value)) {
                fileName = value.name;
            }
            (_a = this.fd) === null || _a === void 0 ? void 0 : _a.append(key, new Blob([
                value
            ]), fileName);
        });
    }
    getRequest() {
        return {
            body: this.fd,
            headers: {}
        };
    }
}
exports.WebFormData = WebFormData;
}),
"[project]/node_modules/cohere-ai/core/form-data-utils/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeAsFormParameter = void 0;
var encodeAsFormParameter_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/form-data-utils/encodeAsFormParameter.js [app-route] (ecmascript)");
Object.defineProperty(exports, "encodeAsFormParameter", {
    enumerable: true,
    get: function() {
        return encodeAsFormParameter_1.encodeAsFormParameter;
    }
});
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/form-data-utils/FormDataWrapper.js [app-route] (ecmascript)"), exports);
}),
"[project]/node_modules/cohere-ai/core/logging/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/logging/logger.js [app-route] (ecmascript)"), exports);
}),
"[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SchemaType = void 0;
exports.SchemaType = {
    BIGINT: "bigint",
    DATE: "date",
    ENUM: "enum",
    LIST: "list",
    STRING_LITERAL: "stringLiteral",
    BOOLEAN_LITERAL: "booleanLiteral",
    OBJECT: "object",
    ANY: "any",
    BOOLEAN: "boolean",
    NUMBER: "number",
    STRING: "string",
    UNKNOWN: "unknown",
    NEVER: "never",
    RECORD: "record",
    SET: "set",
    UNION: "union",
    UNDISCRIMINATED_UNION: "undiscriminatedUnion",
    NULLABLE: "nullable",
    OPTIONAL: "optional",
    OPTIONAL_NULLABLE: "optionalNullable"
};
}),
"[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getErrorMessageForIncorrectType = getErrorMessageForIncorrectType;
function getErrorMessageForIncorrectType(value, expectedType) {
    return `Expected ${expectedType}. Received ${getTypeAsString(value)}.`;
}
function getTypeAsString(value) {
    if (Array.isArray(value)) {
        return "list";
    }
    if (value === null) {
        return "null";
    }
    if (value instanceof BigInt) {
        return "BigInt";
    }
    switch(typeof value){
        case "string":
            return `"${value}"`;
        case "bigint":
        case "number":
        case "boolean":
        case "undefined":
            return `${value}`;
    }
    return typeof value;
}
}),
"[project]/node_modules/cohere-ai/core/schemas/utils/maybeSkipValidation.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.maybeSkipValidation = maybeSkipValidation;
function maybeSkipValidation(schema) {
    return Object.assign(Object.assign({}, schema), {
        json: transformAndMaybeSkipValidation(schema.json),
        parse: transformAndMaybeSkipValidation(schema.parse)
    });
}
function transformAndMaybeSkipValidation(transform) {
    return (value, opts)=>{
        const transformed = transform(value, opts);
        const { skipValidation = false } = opts !== null && opts !== void 0 ? opts : {};
        if (!transformed.ok && skipValidation) {
            // biome-ignore lint/suspicious/noConsole: allow console
            console.warn([
                "Failed to validate.",
                ...transformed.errors.map((error)=>"  - " + (error.path.length > 0 ? `${error.path.join(".")}: ${error.message}` : error.message))
            ].join("\n"));
            return {
                ok: true,
                value: value
            };
        } else {
            return transformed;
        }
    };
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/stringifyValidationErrors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringifyValidationError = stringifyValidationError;
function stringifyValidationError(error) {
    if (error.path.length === 0) {
        return error.message;
    }
    return `${error.path.join(" -> ")}: ${error.message}`;
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/JsonError.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JsonError = void 0;
const stringifyValidationErrors_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/stringifyValidationErrors.js [app-route] (ecmascript)");
class JsonError extends Error {
    constructor(errors){
        super(errors.map(stringifyValidationErrors_1.stringifyValidationError).join("; "));
        this.errors = errors;
        Object.setPrototypeOf(this, JsonError.prototype);
    }
}
exports.JsonError = JsonError;
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/ParseError.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParseError = void 0;
const stringifyValidationErrors_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/stringifyValidationErrors.js [app-route] (ecmascript)");
class ParseError extends Error {
    constructor(errors){
        super(errors.map(stringifyValidationErrors_1.stringifyValidationError).join("; "));
        this.errors = errors;
        Object.setPrototypeOf(this, ParseError.prototype);
    }
}
exports.ParseError = ParseError;
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/getSchemaUtils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getSchemaUtils = getSchemaUtils;
exports.nullable = nullable;
exports.optional = optional;
exports.optionalNullable = optionalNullable;
exports.transform = transform;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const JsonError_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/JsonError.js [app-route] (ecmascript)");
const ParseError_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/ParseError.js [app-route] (ecmascript)");
function getSchemaUtils(schema) {
    return {
        nullable: ()=>nullable(schema),
        optional: ()=>optional(schema),
        optionalNullable: ()=>optionalNullable(schema),
        transform: (transformer)=>transform(schema, transformer),
        parseOrThrow: (raw, opts)=>{
            const parsed = schema.parse(raw, opts);
            if (parsed.ok) {
                return parsed.value;
            }
            throw new ParseError_1.ParseError(parsed.errors);
        },
        jsonOrThrow: (parsed, opts)=>{
            const raw = schema.json(parsed, opts);
            if (raw.ok) {
                return raw.value;
            }
            throw new JsonError_1.JsonError(raw.errors);
        }
    };
}
/**
 * schema utils are defined in one file to resolve issues with circular imports
 */ function nullable(schema) {
    const baseSchema = {
        parse: (raw, opts)=>{
            if (raw == null) {
                return {
                    ok: true,
                    value: null
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts)=>{
            if (parsed == null) {
                return {
                    ok: true,
                    value: null
                };
            }
            return schema.json(parsed, opts);
        },
        getType: ()=>Schema_1.SchemaType.NULLABLE
    };
    return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
}
function optional(schema) {
    const baseSchema = {
        parse: (raw, opts)=>{
            if (raw == null) {
                return {
                    ok: true,
                    value: undefined
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts)=>{
            if ((opts === null || opts === void 0 ? void 0 : opts.omitUndefined) && parsed === undefined) {
                return {
                    ok: true,
                    value: undefined
                };
            }
            if (parsed == null) {
                return {
                    ok: true,
                    value: null
                };
            }
            return schema.json(parsed, opts);
        },
        getType: ()=>Schema_1.SchemaType.OPTIONAL
    };
    return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
}
function optionalNullable(schema) {
    const baseSchema = {
        parse: (raw, opts)=>{
            if (raw === undefined) {
                return {
                    ok: true,
                    value: undefined
                };
            }
            if (raw === null) {
                return {
                    ok: true,
                    value: null
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts)=>{
            if (parsed === undefined) {
                return {
                    ok: true,
                    value: undefined
                };
            }
            if (parsed === null) {
                return {
                    ok: true,
                    value: null
                };
            }
            return schema.json(parsed, opts);
        },
        getType: ()=>Schema_1.SchemaType.OPTIONAL_NULLABLE
    };
    return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
}
function transform(schema, transformer) {
    const baseSchema = {
        parse: (raw, opts)=>{
            const parsed = schema.parse(raw, opts);
            if (!parsed.ok) {
                return parsed;
            }
            return {
                ok: true,
                value: transformer.transform(parsed.value)
            };
        },
        json: (transformed, opts)=>{
            const parsed = transformer.untransform(transformed);
            return schema.json(parsed, opts);
        },
        getType: ()=>schema.getType()
    };
    return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParseError = exports.JsonError = exports.transform = exports.optional = exports.getSchemaUtils = void 0;
var getSchemaUtils_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/getSchemaUtils.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getSchemaUtils", {
    enumerable: true,
    get: function() {
        return getSchemaUtils_1.getSchemaUtils;
    }
});
Object.defineProperty(exports, "optional", {
    enumerable: true,
    get: function() {
        return getSchemaUtils_1.optional;
    }
});
Object.defineProperty(exports, "transform", {
    enumerable: true,
    get: function() {
        return getSchemaUtils_1.transform;
    }
});
var JsonError_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/JsonError.js [app-route] (ecmascript)");
Object.defineProperty(exports, "JsonError", {
    enumerable: true,
    get: function() {
        return JsonError_1.JsonError;
    }
});
var ParseError_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/ParseError.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ParseError", {
    enumerable: true,
    get: function() {
        return ParseError_1.ParseError;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/bigint/bigint.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bigint = bigint;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/maybeSkipValidation.js [app-route] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)");
function bigint() {
    const baseSchema = {
        parse: (raw, { breadcrumbsPrefix = [] } = {})=>{
            if (typeof raw === "bigint") {
                return {
                    ok: true,
                    value: raw
                };
            }
            if (typeof raw === "number") {
                return {
                    ok: true,
                    value: BigInt(raw)
                };
            }
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, "bigint | number")
                    }
                ]
            };
        },
        json: (bigint, { breadcrumbsPrefix = [] } = {})=>{
            if (typeof bigint !== "bigint") {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(bigint, "bigint")
                        }
                    ]
                };
            }
            return {
                ok: true,
                value: bigint
            };
        },
        getType: ()=>Schema_1.SchemaType.BIGINT
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, index_1.getSchemaUtils)(baseSchema));
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/bigint/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bigint = void 0;
var bigint_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/bigint/bigint.js [app-route] (ecmascript)");
Object.defineProperty(exports, "bigint", {
    enumerable: true,
    get: function() {
        return bigint_1.bigint;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/date/date.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.date = date;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/maybeSkipValidation.js [app-route] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)");
// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime
const ISO_8601_REGEX = /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
function date() {
    const baseSchema = {
        parse: (raw, { breadcrumbsPrefix = [] } = {})=>{
            if (typeof raw !== "string") {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, "string")
                        }
                    ]
                };
            }
            if (!ISO_8601_REGEX.test(raw)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, "ISO 8601 date string")
                        }
                    ]
                };
            }
            return {
                ok: true,
                value: new Date(raw)
            };
        },
        json: (date, { breadcrumbsPrefix = [] } = {})=>{
            if (date instanceof Date) {
                return {
                    ok: true,
                    value: date.toISOString()
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(date, "Date object")
                        }
                    ]
                };
            }
        },
        getType: ()=>Schema_1.SchemaType.DATE
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, index_1.getSchemaUtils)(baseSchema));
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/date/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.date = void 0;
var date_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/date/date.js [app-route] (ecmascript)");
Object.defineProperty(exports, "date", {
    enumerable: true,
    get: function() {
        return date_1.date;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/utils/createIdentitySchemaCreator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createIdentitySchemaCreator = createIdentitySchemaCreator;
const index_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/maybeSkipValidation.js [app-route] (ecmascript)");
function createIdentitySchemaCreator(schemaType, validate) {
    return ()=>{
        const baseSchema = {
            parse: validate,
            json: validate,
            getType: ()=>schemaType
        };
        return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, index_1.getSchemaUtils)(baseSchema));
    };
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/enum/enum.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.enum_ = enum_;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/createIdentitySchemaCreator.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
function enum_(values) {
    const validValues = new Set(values);
    const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.ENUM, (value, { allowUnrecognizedEnumValues, breadcrumbsPrefix = [] } = {})=>{
        if (typeof value !== "string") {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "string")
                    }
                ]
            };
        }
        if (!validValues.has(value) && !allowUnrecognizedEnumValues) {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "enum")
                    }
                ]
            };
        }
        return {
            ok: true,
            value: value
        };
    });
    return schemaCreator();
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/enum/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.enum_ = void 0;
var enum_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/enum/enum.js [app-route] (ecmascript)");
Object.defineProperty(exports, "enum_", {
    enumerable: true,
    get: function() {
        return enum_1.enum_;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/lazy/lazy.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.lazy = lazy;
exports.constructLazyBaseSchema = constructLazyBaseSchema;
exports.getMemoizedSchema = getMemoizedSchema;
const index_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)");
function lazy(getter) {
    const baseSchema = constructLazyBaseSchema(getter);
    return Object.assign(Object.assign({}, baseSchema), (0, index_1.getSchemaUtils)(baseSchema));
}
function constructLazyBaseSchema(getter) {
    return {
        parse: (raw, opts)=>getMemoizedSchema(getter).parse(raw, opts),
        json: (parsed, opts)=>getMemoizedSchema(getter).json(parsed, opts),
        getType: ()=>getMemoizedSchema(getter).getType()
    };
}
function getMemoizedSchema(getter) {
    const castedGetter = getter;
    if (castedGetter.__zurg_memoized == null) {
        castedGetter.__zurg_memoized = getter();
    }
    return castedGetter.__zurg_memoized;
}
}),
"[project]/node_modules/cohere-ai/core/schemas/utils/entries.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.entries = entries;
function entries(object) {
    return Object.entries(object);
}
}),
"[project]/node_modules/cohere-ai/core/schemas/utils/filterObject.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.filterObject = filterObject;
function filterObject(obj, keysToInclude) {
    const keysToIncludeSet = new Set(keysToInclude);
    return Object.entries(obj).reduce((acc, [key, value])=>{
        if (keysToIncludeSet.has(key)) {
            acc[key] = value;
        }
        return acc;
    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
    }, {});
}
}),
"[project]/node_modules/cohere-ai/core/schemas/utils/isPlainObject.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isPlainObject = isPlainObject;
// borrowed from https://github.com/lodash/lodash/blob/master/isPlainObject.js
function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
        return false;
    }
    if (Object.getPrototypeOf(value) === null) {
        return true;
    }
    let proto = value;
    while(Object.getPrototypeOf(proto) !== null){
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
}
}),
"[project]/node_modules/cohere-ai/core/schemas/utils/keys.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.keys = keys;
function keys(object) {
    return Object.keys(object);
}
}),
"[project]/node_modules/cohere-ai/core/schemas/utils/partition.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.partition = partition;
function partition(items, predicate) {
    const trueItems = [], falseItems = [];
    for (const item of items){
        if (predicate(item)) {
            trueItems.push(item);
        } else {
            falseItems.push(item);
        }
    }
    return [
        trueItems,
        falseItems
    ];
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/object-like/getObjectLikeUtils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getObjectLikeUtils = getObjectLikeUtils;
exports.withParsedProperties = withParsedProperties;
const filterObject_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/filterObject.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
const isPlainObject_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/isPlainObject.js [app-route] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)");
function getObjectLikeUtils(schema) {
    return {
        withParsedProperties: (properties)=>withParsedProperties(schema, properties)
    };
}
/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */ function withParsedProperties(objectLike, properties) {
    const objectSchema = {
        parse: (raw, opts)=>{
            const parsedObject = objectLike.parse(raw, opts);
            if (!parsedObject.ok) {
                return parsedObject;
            }
            const additionalProperties = Object.entries(properties).reduce((processed, [key, value])=>{
                return Object.assign(Object.assign({}, processed), {
                    [key]: typeof value === "function" ? value(parsedObject.value) : value
                });
            }, {});
            return {
                ok: true,
                value: Object.assign(Object.assign({}, parsedObject.value), additionalProperties)
            };
        },
        json: (parsed, opts)=>{
            var _a;
            if (!(0, isPlainObject_1.isPlainObject)(parsed)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: (_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(parsed, "object")
                        }
                    ]
                };
            }
            // strip out added properties
            const addedPropertyKeys = new Set(Object.keys(properties));
            const parsedWithoutAddedProperties = (0, filterObject_1.filterObject)(parsed, Object.keys(parsed).filter((key)=>!addedPropertyKeys.has(key)));
            return objectLike.json(parsedWithoutAddedProperties, opts);
        },
        getType: ()=>objectLike.getType()
    };
    return Object.assign(Object.assign(Object.assign({}, objectSchema), (0, index_1.getSchemaUtils)(objectSchema)), getObjectLikeUtils(objectSchema));
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/object-like/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.withParsedProperties = exports.getObjectLikeUtils = void 0;
var getObjectLikeUtils_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/object-like/getObjectLikeUtils.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getObjectLikeUtils", {
    enumerable: true,
    get: function() {
        return getObjectLikeUtils_1.getObjectLikeUtils;
    }
});
Object.defineProperty(exports, "withParsedProperties", {
    enumerable: true,
    get: function() {
        return getObjectLikeUtils_1.withParsedProperties;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/object/property.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.property = property;
exports.isProperty = isProperty;
function property(rawKey, valueSchema) {
    return {
        rawKey,
        valueSchema,
        isProperty: true
    };
}
function isProperty(maybeProperty) {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return maybeProperty.isProperty;
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/object/object.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.object = object;
exports.getObjectUtils = getObjectUtils;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const entries_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/entries.js [app-route] (ecmascript)");
const filterObject_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/filterObject.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
const isPlainObject_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/isPlainObject.js [app-route] (ecmascript)");
const keys_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/keys.js [app-route] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/maybeSkipValidation.js [app-route] (ecmascript)");
const partition_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/partition.js [app-route] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/object-like/index.js [app-route] (ecmascript)");
const index_2 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)");
const property_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/object/property.js [app-route] (ecmascript)");
function object(schemas) {
    const baseSchema = {
        _getRawProperties: ()=>Object.entries(schemas).map(([parsedKey, propertySchema])=>(0, property_1.isProperty)(propertySchema) ? propertySchema.rawKey : parsedKey),
        _getParsedProperties: ()=>(0, keys_1.keys)(schemas),
        parse: (raw, opts)=>{
            const rawKeyToProperty = {};
            const requiredKeys = [];
            for (const [parsedKey, schemaOrObjectProperty] of (0, entries_1.entries)(schemas)){
                const rawKey = (0, property_1.isProperty)(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
                const valueSchema = (0, property_1.isProperty)(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty;
                const property = {
                    rawKey,
                    parsedKey: parsedKey,
                    valueSchema
                };
                rawKeyToProperty[rawKey] = property;
                if (isSchemaRequired(valueSchema)) {
                    requiredKeys.push(rawKey);
                }
            }
            return validateAndTransformObject({
                value: raw,
                requiredKeys,
                getProperty: (rawKey)=>{
                    const property = rawKeyToProperty[rawKey];
                    if (property == null) {
                        return undefined;
                    }
                    return {
                        transformedKey: property.parsedKey,
                        transform: (propertyValue)=>{
                            var _a;
                            return property.valueSchema.parse(propertyValue, Object.assign(Object.assign({}, opts), {
                                breadcrumbsPrefix: [
                                    ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                                    rawKey
                                ]
                            }));
                        }
                    };
                },
                unrecognizedObjectKeys: opts === null || opts === void 0 ? void 0 : opts.unrecognizedObjectKeys,
                skipValidation: opts === null || opts === void 0 ? void 0 : opts.skipValidation,
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix,
                omitUndefined: opts === null || opts === void 0 ? void 0 : opts.omitUndefined
            });
        },
        json: (parsed, opts)=>{
            const requiredKeys = [];
            for (const [parsedKey, schemaOrObjectProperty] of (0, entries_1.entries)(schemas)){
                const valueSchema = (0, property_1.isProperty)(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty;
                if (isSchemaRequired(valueSchema)) {
                    requiredKeys.push(parsedKey);
                }
            }
            return validateAndTransformObject({
                value: parsed,
                requiredKeys,
                getProperty: (parsedKey)=>{
                    const property = schemas[parsedKey];
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    if (property == null) {
                        return undefined;
                    }
                    if ((0, property_1.isProperty)(property)) {
                        return {
                            transformedKey: property.rawKey,
                            transform: (propertyValue)=>{
                                var _a;
                                return property.valueSchema.json(propertyValue, Object.assign(Object.assign({}, opts), {
                                    breadcrumbsPrefix: [
                                        ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                                        parsedKey
                                    ]
                                }));
                            }
                        };
                    } else {
                        return {
                            transformedKey: parsedKey,
                            transform: (propertyValue)=>{
                                var _a;
                                return property.json(propertyValue, Object.assign(Object.assign({}, opts), {
                                    breadcrumbsPrefix: [
                                        ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                                        parsedKey
                                    ]
                                }));
                            }
                        };
                    }
                },
                unrecognizedObjectKeys: opts === null || opts === void 0 ? void 0 : opts.unrecognizedObjectKeys,
                skipValidation: opts === null || opts === void 0 ? void 0 : opts.skipValidation,
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix,
                omitUndefined: opts === null || opts === void 0 ? void 0 : opts.omitUndefined
            });
        },
        getType: ()=>Schema_1.SchemaType.OBJECT
    };
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, index_2.getSchemaUtils)(baseSchema)), (0, index_1.getObjectLikeUtils)(baseSchema)), getObjectUtils(baseSchema));
}
function validateAndTransformObject({ value, requiredKeys, getProperty, unrecognizedObjectKeys = "fail", skipValidation = false, breadcrumbsPrefix = [] }) {
    if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "object")
                }
            ]
        };
    }
    const missingRequiredKeys = new Set(requiredKeys);
    const errors = [];
    const transformed = {};
    for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)){
        const property = getProperty(preTransformedKey);
        if (property != null) {
            missingRequiredKeys.delete(preTransformedKey);
            const value = property.transform(preTransformedItemValue);
            if (value.ok) {
                transformed[property.transformedKey] = value.value;
            } else {
                transformed[preTransformedKey] = preTransformedItemValue;
                errors.push(...value.errors);
            }
        } else {
            switch(unrecognizedObjectKeys){
                case "fail":
                    errors.push({
                        path: [
                            ...breadcrumbsPrefix,
                            preTransformedKey
                        ],
                        message: `Unexpected key "${preTransformedKey}"`
                    });
                    break;
                case "strip":
                    break;
                case "passthrough":
                    transformed[preTransformedKey] = preTransformedItemValue;
                    break;
            }
        }
    }
    errors.push(...requiredKeys.filter((key)=>missingRequiredKeys.has(key)).map((key)=>({
            path: breadcrumbsPrefix,
            message: `Missing required key "${key}"`
        })));
    if (errors.length === 0 || skipValidation) {
        return {
            ok: true,
            value: transformed
        };
    } else {
        return {
            ok: false,
            errors
        };
    }
}
function getObjectUtils(schema) {
    return {
        extend: (extension)=>{
            const baseSchema = {
                _getParsedProperties: ()=>[
                        ...schema._getParsedProperties(),
                        ...extension._getParsedProperties()
                    ],
                _getRawProperties: ()=>[
                        ...schema._getRawProperties(),
                        ...extension._getRawProperties()
                    ],
                parse: (raw, opts)=>{
                    return validateAndTransformExtendedObject({
                        extensionKeys: extension._getRawProperties(),
                        value: raw,
                        transformBase: (rawBase)=>schema.parse(rawBase, opts),
                        transformExtension: (rawExtension)=>extension.parse(rawExtension, opts)
                    });
                },
                json: (parsed, opts)=>{
                    return validateAndTransformExtendedObject({
                        extensionKeys: extension._getParsedProperties(),
                        value: parsed,
                        transformBase: (parsedBase)=>schema.json(parsedBase, opts),
                        transformExtension: (parsedExtension)=>extension.json(parsedExtension, opts)
                    });
                },
                getType: ()=>Schema_1.SchemaType.OBJECT
            };
            return Object.assign(Object.assign(Object.assign(Object.assign({}, baseSchema), (0, index_2.getSchemaUtils)(baseSchema)), (0, index_1.getObjectLikeUtils)(baseSchema)), getObjectUtils(baseSchema));
        },
        passthrough: ()=>{
            const baseSchema = {
                _getParsedProperties: ()=>schema._getParsedProperties(),
                _getRawProperties: ()=>schema._getRawProperties(),
                parse: (raw, opts)=>{
                    const transformed = schema.parse(raw, Object.assign(Object.assign({}, opts), {
                        unrecognizedObjectKeys: "passthrough"
                    }));
                    if (!transformed.ok) {
                        return transformed;
                    }
                    return {
                        ok: true,
                        value: Object.assign(Object.assign({}, raw), transformed.value)
                    };
                },
                json: (parsed, opts)=>{
                    const transformed = schema.json(parsed, Object.assign(Object.assign({}, opts), {
                        unrecognizedObjectKeys: "passthrough"
                    }));
                    if (!transformed.ok) {
                        return transformed;
                    }
                    return {
                        ok: true,
                        value: Object.assign(Object.assign({}, parsed), transformed.value)
                    };
                },
                getType: ()=>Schema_1.SchemaType.OBJECT
            };
            return Object.assign(Object.assign(Object.assign(Object.assign({}, baseSchema), (0, index_2.getSchemaUtils)(baseSchema)), (0, index_1.getObjectLikeUtils)(baseSchema)), getObjectUtils(baseSchema));
        }
    };
}
function validateAndTransformExtendedObject({ extensionKeys, value, transformBase, transformExtension }) {
    const extensionPropertiesSet = new Set(extensionKeys);
    const [extensionProperties, baseProperties] = (0, partition_1.partition)((0, keys_1.keys)(value), (key)=>extensionPropertiesSet.has(key));
    const transformedBase = transformBase((0, filterObject_1.filterObject)(value, baseProperties));
    const transformedExtension = transformExtension((0, filterObject_1.filterObject)(value, extensionProperties));
    if (transformedBase.ok && transformedExtension.ok) {
        return {
            ok: true,
            value: Object.assign(Object.assign({}, transformedBase.value), transformedExtension.value)
        };
    } else {
        return {
            ok: false,
            errors: [
                ...transformedBase.ok ? [] : transformedBase.errors,
                ...transformedExtension.ok ? [] : transformedExtension.errors
            ]
        };
    }
}
function isSchemaRequired(schema) {
    return !isSchemaOptional(schema);
}
function isSchemaOptional(schema) {
    switch(schema.getType()){
        case Schema_1.SchemaType.ANY:
        case Schema_1.SchemaType.UNKNOWN:
        case Schema_1.SchemaType.OPTIONAL:
        case Schema_1.SchemaType.OPTIONAL_NULLABLE:
            return true;
        default:
            return false;
    }
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/object/objectWithoutOptionalProperties.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.objectWithoutOptionalProperties = objectWithoutOptionalProperties;
const object_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/object/object.js [app-route] (ecmascript)");
function objectWithoutOptionalProperties(schemas) {
    return (0, object_1.object)(schemas);
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/object/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.property = exports.isProperty = exports.objectWithoutOptionalProperties = exports.object = exports.getObjectUtils = void 0;
var object_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/object/object.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getObjectUtils", {
    enumerable: true,
    get: function() {
        return object_1.getObjectUtils;
    }
});
Object.defineProperty(exports, "object", {
    enumerable: true,
    get: function() {
        return object_1.object;
    }
});
var objectWithoutOptionalProperties_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/object/objectWithoutOptionalProperties.js [app-route] (ecmascript)");
Object.defineProperty(exports, "objectWithoutOptionalProperties", {
    enumerable: true,
    get: function() {
        return objectWithoutOptionalProperties_1.objectWithoutOptionalProperties;
    }
});
var property_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/object/property.js [app-route] (ecmascript)");
Object.defineProperty(exports, "isProperty", {
    enumerable: true,
    get: function() {
        return property_1.isProperty;
    }
});
Object.defineProperty(exports, "property", {
    enumerable: true,
    get: function() {
        return property_1.property;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/lazy/lazyObject.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.lazyObject = lazyObject;
const index_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/object/index.js [app-route] (ecmascript)");
const index_2 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/object-like/index.js [app-route] (ecmascript)");
const index_3 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)");
const lazy_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/lazy/lazy.js [app-route] (ecmascript)");
function lazyObject(getter) {
    const baseSchema = Object.assign(Object.assign({}, (0, lazy_1.constructLazyBaseSchema)(getter)), {
        _getRawProperties: ()=>(0, lazy_1.getMemoizedSchema)(getter)._getRawProperties(),
        _getParsedProperties: ()=>(0, lazy_1.getMemoizedSchema)(getter)._getParsedProperties()
    });
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseSchema), (0, index_3.getSchemaUtils)(baseSchema)), (0, index_2.getObjectLikeUtils)(baseSchema)), (0, index_1.getObjectUtils)(baseSchema));
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/lazy/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.lazyObject = exports.lazy = void 0;
var lazy_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/lazy/lazy.js [app-route] (ecmascript)");
Object.defineProperty(exports, "lazy", {
    enumerable: true,
    get: function() {
        return lazy_1.lazy;
    }
});
var lazyObject_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/lazy/lazyObject.js [app-route] (ecmascript)");
Object.defineProperty(exports, "lazyObject", {
    enumerable: true,
    get: function() {
        return lazyObject_1.lazyObject;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/list/list.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.list = list;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/maybeSkipValidation.js [app-route] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)");
function list(schema) {
    const baseSchema = {
        parse: (raw, opts)=>validateAndTransformArray(raw, (item, index)=>{
                var _a;
                return schema.parse(item, Object.assign(Object.assign({}, opts), {
                    breadcrumbsPrefix: [
                        ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                        `[${index}]`
                    ]
                }));
            }),
        json: (parsed, opts)=>validateAndTransformArray(parsed, (item, index)=>{
                var _a;
                return schema.json(item, Object.assign(Object.assign({}, opts), {
                    breadcrumbsPrefix: [
                        ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                        `[${index}]`
                    ]
                }));
            }),
        getType: ()=>Schema_1.SchemaType.LIST
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, index_1.getSchemaUtils)(baseSchema));
}
function validateAndTransformArray(value, transformItem) {
    if (!Array.isArray(value)) {
        return {
            ok: false,
            errors: [
                {
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "list"),
                    path: []
                }
            ]
        };
    }
    const maybeValidItems = value.map((item, index)=>transformItem(item, index));
    return maybeValidItems.reduce((acc, item)=>{
        if (acc.ok && item.ok) {
            return {
                ok: true,
                value: [
                    ...acc.value,
                    item.value
                ]
            };
        }
        const errors = [];
        if (!acc.ok) {
            errors.push(...acc.errors);
        }
        if (!item.ok) {
            errors.push(...item.errors);
        }
        return {
            ok: false,
            errors
        };
    }, {
        ok: true,
        value: []
    });
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/list/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.list = void 0;
var list_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/list/list.js [app-route] (ecmascript)");
Object.defineProperty(exports, "list", {
    enumerable: true,
    get: function() {
        return list_1.list;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/literals/booleanLiteral.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.booleanLiteral = booleanLiteral;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/createIdentitySchemaCreator.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
function booleanLiteral(literal) {
    const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.BOOLEAN_LITERAL, (value, { breadcrumbsPrefix = [] } = {})=>{
        if (value === literal) {
            return {
                ok: true,
                value: literal
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, `${literal.toString()}`)
                    }
                ]
            };
        }
    });
    return schemaCreator();
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/literals/stringLiteral.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringLiteral = stringLiteral;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/createIdentitySchemaCreator.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
function stringLiteral(literal) {
    const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.STRING_LITERAL, (value, { breadcrumbsPrefix = [] } = {})=>{
        if (value === literal) {
            return {
                ok: true,
                value: literal
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, `"${literal}"`)
                    }
                ]
            };
        }
    });
    return schemaCreator();
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/literals/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringLiteral = exports.booleanLiteral = void 0;
var booleanLiteral_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/literals/booleanLiteral.js [app-route] (ecmascript)");
Object.defineProperty(exports, "booleanLiteral", {
    enumerable: true,
    get: function() {
        return booleanLiteral_1.booleanLiteral;
    }
});
var stringLiteral_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/literals/stringLiteral.js [app-route] (ecmascript)");
Object.defineProperty(exports, "stringLiteral", {
    enumerable: true,
    get: function() {
        return stringLiteral_1.stringLiteral;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/primitives/any.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.any = void 0;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/createIdentitySchemaCreator.js [app-route] (ecmascript)");
exports.any = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.ANY, (value)=>({
        ok: true,
        value
    }));
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/primitives/boolean.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.boolean = void 0;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/createIdentitySchemaCreator.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
exports.boolean = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.BOOLEAN, (value, { breadcrumbsPrefix = [] } = {})=>{
    if (typeof value === "boolean") {
        return {
            ok: true,
            value
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "boolean")
                }
            ]
        };
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/primitives/never.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.never = void 0;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/createIdentitySchemaCreator.js [app-route] (ecmascript)");
exports.never = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.NEVER, (_value, { breadcrumbsPrefix = [] } = {})=>({
        ok: false,
        errors: [
            {
                path: breadcrumbsPrefix,
                message: "Expected never"
            }
        ]
    }));
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/primitives/number.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.number = void 0;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/createIdentitySchemaCreator.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
exports.number = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.NUMBER, (value, { breadcrumbsPrefix = [] } = {})=>{
    if (typeof value === "number") {
        return {
            ok: true,
            value
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "number")
                }
            ]
        };
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/primitives/string.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.string = void 0;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/createIdentitySchemaCreator.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
exports.string = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.STRING, (value, { breadcrumbsPrefix = [] } = {})=>{
    if (typeof value === "string") {
        return {
            ok: true,
            value
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "string")
                }
            ]
        };
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/primitives/unknown.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unknown = void 0;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/createIdentitySchemaCreator.js [app-route] (ecmascript)");
exports.unknown = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.UNKNOWN, (value)=>({
        ok: true,
        value
    }));
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/primitives/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unknown = exports.string = exports.number = exports.never = exports.boolean = exports.any = void 0;
var any_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/primitives/any.js [app-route] (ecmascript)");
Object.defineProperty(exports, "any", {
    enumerable: true,
    get: function() {
        return any_1.any;
    }
});
var boolean_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/primitives/boolean.js [app-route] (ecmascript)");
Object.defineProperty(exports, "boolean", {
    enumerable: true,
    get: function() {
        return boolean_1.boolean;
    }
});
var never_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/primitives/never.js [app-route] (ecmascript)");
Object.defineProperty(exports, "never", {
    enumerable: true,
    get: function() {
        return never_1.never;
    }
});
var number_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/primitives/number.js [app-route] (ecmascript)");
Object.defineProperty(exports, "number", {
    enumerable: true,
    get: function() {
        return number_1.number;
    }
});
var string_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/primitives/string.js [app-route] (ecmascript)");
Object.defineProperty(exports, "string", {
    enumerable: true,
    get: function() {
        return string_1.string;
    }
});
var unknown_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/primitives/unknown.js [app-route] (ecmascript)");
Object.defineProperty(exports, "unknown", {
    enumerable: true,
    get: function() {
        return unknown_1.unknown;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/record/record.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.record = record;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const entries_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/entries.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
const isPlainObject_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/isPlainObject.js [app-route] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/maybeSkipValidation.js [app-route] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)");
function record(keySchema, valueSchema) {
    const baseSchema = {
        parse: (raw, opts)=>{
            return validateAndTransformRecord({
                value: raw,
                isKeyNumeric: keySchema.getType() === Schema_1.SchemaType.NUMBER,
                transformKey: (key)=>{
                    var _a;
                    return keySchema.parse(key, Object.assign(Object.assign({}, opts), {
                        breadcrumbsPrefix: [
                            ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            `${key} (key)`
                        ]
                    }));
                },
                transformValue: (value, key)=>{
                    var _a;
                    return valueSchema.parse(value, Object.assign(Object.assign({}, opts), {
                        breadcrumbsPrefix: [
                            ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            `${key}`
                        ]
                    }));
                },
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix
            });
        },
        json: (parsed, opts)=>{
            return validateAndTransformRecord({
                value: parsed,
                isKeyNumeric: keySchema.getType() === Schema_1.SchemaType.NUMBER,
                transformKey: (key)=>{
                    var _a;
                    return keySchema.json(key, Object.assign(Object.assign({}, opts), {
                        breadcrumbsPrefix: [
                            ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            `${key} (key)`
                        ]
                    }));
                },
                transformValue: (value, key)=>{
                    var _a;
                    return valueSchema.json(value, Object.assign(Object.assign({}, opts), {
                        breadcrumbsPrefix: [
                            ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            `${key}`
                        ]
                    }));
                },
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix
            });
        },
        getType: ()=>Schema_1.SchemaType.RECORD
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, index_1.getSchemaUtils)(baseSchema));
}
function validateAndTransformRecord({ value, isKeyNumeric, transformKey, transformValue, breadcrumbsPrefix = [] }) {
    if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "object")
                }
            ]
        };
    }
    return (0, entries_1.entries)(value).reduce((accPromise, [stringKey, value])=>{
        if (value === undefined) {
            return accPromise;
        }
        const acc = accPromise;
        let key = stringKey;
        if (isKeyNumeric) {
            const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
            if (!Number.isNaN(numberKey)) {
                key = numberKey;
            }
        }
        const transformedKey = transformKey(key);
        const transformedValue = transformValue(value, key);
        if (acc.ok && transformedKey.ok && transformedValue.ok) {
            return {
                ok: true,
                value: Object.assign(Object.assign({}, acc.value), {
                    [transformedKey.value]: transformedValue.value
                })
            };
        }
        const errors = [];
        if (!acc.ok) {
            errors.push(...acc.errors);
        }
        if (!transformedKey.ok) {
            errors.push(...transformedKey.errors);
        }
        if (!transformedValue.ok) {
            errors.push(...transformedValue.errors);
        }
        return {
            ok: false,
            errors
        };
    }, {
        ok: true,
        value: {}
    });
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/record/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.record = void 0;
var record_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/record/record.js [app-route] (ecmascript)");
Object.defineProperty(exports, "record", {
    enumerable: true,
    get: function() {
        return record_1.record;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/set/set.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.set = set;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/maybeSkipValidation.js [app-route] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/list/index.js [app-route] (ecmascript)");
const index_2 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)");
function set(schema) {
    const listSchema = (0, index_1.list)(schema);
    const baseSchema = {
        parse: (raw, opts)=>{
            const parsedList = listSchema.parse(raw, opts);
            if (parsedList.ok) {
                return {
                    ok: true,
                    value: new Set(parsedList.value)
                };
            } else {
                return parsedList;
            }
        },
        json: (parsed, opts)=>{
            var _a;
            if (!(parsed instanceof Set)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: (_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(parsed, "Set")
                        }
                    ]
                };
            }
            const jsonList = listSchema.json([
                ...parsed
            ], opts);
            return jsonList;
        },
        getType: ()=>Schema_1.SchemaType.SET
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, index_2.getSchemaUtils)(baseSchema));
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/set/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.set = void 0;
var set_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/set/set.js [app-route] (ecmascript)");
Object.defineProperty(exports, "set", {
    enumerable: true,
    get: function() {
        return set_1.set;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.undiscriminatedUnion = undiscriminatedUnion;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/maybeSkipValidation.js [app-route] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)");
function undiscriminatedUnion(schemas) {
    const baseSchema = {
        parse: (raw, opts)=>{
            return validateAndTransformUndiscriminatedUnion((schema, opts)=>schema.parse(raw, opts), schemas, opts);
        },
        json: (parsed, opts)=>{
            return validateAndTransformUndiscriminatedUnion((schema, opts)=>schema.json(parsed, opts), schemas, opts);
        },
        getType: ()=>Schema_1.SchemaType.UNDISCRIMINATED_UNION
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, index_1.getSchemaUtils)(baseSchema));
}
function validateAndTransformUndiscriminatedUnion(transform, schemas, opts) {
    const errors = [];
    for (const [index, schema] of schemas.entries()){
        const transformed = transform(schema, Object.assign(Object.assign({}, opts), {
            skipValidation: false
        }));
        if (transformed.ok) {
            return transformed;
        } else {
            for (const error of transformed.errors){
                errors.push({
                    path: error.path,
                    message: `[Variant ${index}] ${error.message}`
                });
            }
        }
    }
    return {
        ok: false,
        errors
    };
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/undiscriminated-union/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.undiscriminatedUnion = void 0;
var undiscriminatedUnion_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.js [app-route] (ecmascript)");
Object.defineProperty(exports, "undiscriminatedUnion", {
    enumerable: true,
    get: function() {
        return undiscriminatedUnion_1.undiscriminatedUnion;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/union/discriminant.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.discriminant = discriminant;
function discriminant(parsedDiscriminant, rawDiscriminant) {
    return {
        parsedDiscriminant,
        rawDiscriminant
    };
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/union/union.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __rest = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.union = union;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/Schema.js [app-route] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/getErrorMessageForIncorrectType.js [app-route] (ecmascript)");
const isPlainObject_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/isPlainObject.js [app-route] (ecmascript)");
const keys_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/keys.js [app-route] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/utils/maybeSkipValidation.js [app-route] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/enum/index.js [app-route] (ecmascript)");
const object_like_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/object-like/index.js [app-route] (ecmascript)");
const index_2 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)");
function union(discriminant, union) {
    const rawDiscriminant = typeof discriminant === "string" ? discriminant : discriminant.rawDiscriminant;
    const parsedDiscriminant = typeof discriminant === "string" ? discriminant : discriminant.parsedDiscriminant;
    const discriminantValueSchema = (0, index_1.enum_)((0, keys_1.keys)(union));
    const baseSchema = {
        parse: (raw, opts)=>{
            return transformAndValidateUnion({
                value: raw,
                discriminant: rawDiscriminant,
                transformedDiscriminant: parsedDiscriminant,
                transformDiscriminantValue: (discriminantValue)=>{
                    var _a;
                    return discriminantValueSchema.parse(discriminantValue, {
                        allowUnrecognizedEnumValues: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                        breadcrumbsPrefix: [
                            ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            rawDiscriminant
                        ]
                    });
                },
                getAdditionalPropertiesSchema: (discriminantValue)=>union[discriminantValue],
                allowUnrecognizedUnionMembers: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema)=>additionalPropertiesSchema.parse(additionalProperties, opts),
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix
            });
        },
        json: (parsed, opts)=>{
            return transformAndValidateUnion({
                value: parsed,
                discriminant: parsedDiscriminant,
                transformedDiscriminant: rawDiscriminant,
                transformDiscriminantValue: (discriminantValue)=>{
                    var _a;
                    return discriminantValueSchema.json(discriminantValue, {
                        allowUnrecognizedEnumValues: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                        breadcrumbsPrefix: [
                            ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            parsedDiscriminant
                        ]
                    });
                },
                getAdditionalPropertiesSchema: (discriminantValue)=>union[discriminantValue],
                allowUnrecognizedUnionMembers: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema)=>additionalPropertiesSchema.json(additionalProperties, opts),
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix
            });
        },
        getType: ()=>Schema_1.SchemaType.UNION
    };
    return Object.assign(Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, index_2.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema));
}
function transformAndValidateUnion({ value, discriminant, transformedDiscriminant, transformDiscriminantValue, getAdditionalPropertiesSchema, allowUnrecognizedUnionMembers = false, transformAdditionalProperties, breadcrumbsPrefix = [] }) {
    if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "object")
                }
            ]
        };
    }
    const _a = value, _b = discriminant, discriminantValue = _a[_b], additionalProperties = __rest(_a, [
        typeof _b === "symbol" ? _b : _b + ""
    ]);
    if (discriminantValue == null) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: `Missing discriminant ("${discriminant}")`
                }
            ]
        };
    }
    const transformedDiscriminantValue = transformDiscriminantValue(discriminantValue);
    if (!transformedDiscriminantValue.ok) {
        return {
            ok: false,
            errors: transformedDiscriminantValue.errors
        };
    }
    const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);
    if (additionalPropertiesSchema == null) {
        if (allowUnrecognizedUnionMembers) {
            return {
                ok: true,
                value: Object.assign({
                    [transformedDiscriminant]: transformedDiscriminantValue.value
                }, additionalProperties)
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [
                            ...breadcrumbsPrefix,
                            discriminant
                        ],
                        message: "Unexpected discriminant value"
                    }
                ]
            };
        }
    }
    const transformedAdditionalProperties = transformAdditionalProperties(additionalProperties, additionalPropertiesSchema);
    if (!transformedAdditionalProperties.ok) {
        return transformedAdditionalProperties;
    }
    return {
        ok: true,
        value: Object.assign({
            [transformedDiscriminant]: discriminantValue
        }, transformedAdditionalProperties.value)
    };
}
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/union/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.union = exports.discriminant = void 0;
var discriminant_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/union/discriminant.js [app-route] (ecmascript)");
Object.defineProperty(exports, "discriminant", {
    enumerable: true,
    get: function() {
        return discriminant_1.discriminant;
    }
});
var union_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/union/union.js [app-route] (ecmascript)");
Object.defineProperty(exports, "union", {
    enumerable: true,
    get: function() {
        return union_1.union;
    }
});
}),
"[project]/node_modules/cohere-ai/core/schemas/builders/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/bigint/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/date/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/enum/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/lazy/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/list/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/literals/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/object/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/object-like/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/primitives/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/record/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/schema-utils/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/set/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/undiscriminated-union/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/union/index.js [app-route] (ecmascript)"), exports);
}),
"[project]/node_modules/cohere-ai/core/schemas/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/builders/index.js [app-route] (ecmascript)"), exports);
}),
"[project]/node_modules/cohere-ai/core/stream/Stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
var __await = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Stream = void 0;
exports.readableStreamAsyncIterable = readableStreamAsyncIterable;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/runtime/index.js [app-route] (ecmascript)");
const DATA_PREFIX = "data:";
class Stream {
    constructor({ stream, parse, eventShape, signal }){
        this.controller = new AbortController();
        this.stream = stream;
        this.parse = parse;
        if (eventShape.type === "sse") {
            this.prefix = DATA_PREFIX;
            this.messageTerminator = "\n";
            this.streamTerminator = eventShape.streamTerminator;
        } else {
            this.messageTerminator = eventShape.messageTerminator;
        }
        signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", ()=>this.controller.abort());
        // Initialize shared TextDecoder
        if (typeof TextDecoder !== "undefined") {
            this.decoder = new TextDecoder("utf-8");
        }
    }
    iterMessages() {
        return __asyncGenerator(this, arguments, function* iterMessages_1() {
            var _a, e_1, _b, _c;
            this.controller.signal;
            const stream = readableStreamAsyncIterable(this.stream);
            let buf = "";
            let prefixSeen = false;
            try {
                for(var _d = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield __await(stream_1.next()), _a = stream_1_1.done, !_a; _d = true){
                    _c = stream_1_1.value;
                    _d = false;
                    const chunk = _c;
                    buf += this.decodeChunk(chunk);
                    let terminatorIndex;
                    while((terminatorIndex = buf.indexOf(this.messageTerminator)) >= 0){
                        let line = buf.slice(0, terminatorIndex);
                        buf = buf.slice(terminatorIndex + this.messageTerminator.length);
                        if (!line.trim()) {
                            continue;
                        }
                        if (!prefixSeen && this.prefix != null) {
                            const prefixIndex = line.indexOf(this.prefix);
                            if (prefixIndex === -1) {
                                continue;
                            }
                            prefixSeen = true;
                            line = line.slice(prefixIndex + this.prefix.length);
                        }
                        if (this.streamTerminator != null && line.includes(this.streamTerminator)) {
                            return yield __await(void 0);
                        }
                        const message = yield __await(this.parse(JSON.parse(line)));
                        yield yield __await(message);
                        prefixSeen = false;
                    }
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (!_d && !_a && (_b = stream_1.return)) yield __await(_b.call(stream_1));
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        });
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            var _b, e_2, _c, _d;
            try {
                for(var _e = true, _f = __asyncValues(this.iterMessages()), _g; _g = yield __await(_f.next()), _b = _g.done, !_b; _e = true){
                    _d = _g.value;
                    _e = false;
                    const message = _d;
                    yield yield __await(message);
                }
            } catch (e_2_1) {
                e_2 = {
                    error: e_2_1
                };
            } finally{
                try {
                    if (!_e && !_b && (_c = _f.return)) yield __await(_c.call(_f));
                } finally{
                    if (e_2) throw e_2.error;
                }
            }
        });
    }
    decodeChunk(chunk) {
        let decoded = "";
        // If TextDecoder is available, use the streaming decoder instance
        if (this.decoder != null) {
            decoded += this.decoder.decode(chunk, {
                stream: true
            });
        } else if (runtime_1.RUNTIME.type === "node" && typeof chunk !== "undefined") {
            decoded += Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
        }
        return decoded;
    }
}
exports.Stream = Stream;
/**
 * Browser polyfill for ReadableStream
 */ // biome-ignore lint/suspicious/noExplicitAny: allow explicit any
function readableStreamAsyncIterable(stream) {
    if (stream[Symbol.asyncIterator]) {
        return stream;
    }
    const reader = stream.getReader();
    return {
        next () {
            return __awaiter(this, void 0, void 0, function*() {
                try {
                    const result = yield reader.read();
                    if (result === null || result === void 0 ? void 0 : result.done) {
                        reader.releaseLock();
                    } // release lock when stream becomes closed
                    return result;
                } catch (e) {
                    reader.releaseLock(); // release lock when stream becomes errored
                    throw e;
                }
            });
        },
        return () {
            return __awaiter(this, void 0, void 0, function*() {
                const cancelPromise = reader.cancel();
                reader.releaseLock();
                yield cancelPromise;
                return {
                    done: true,
                    value: undefined
                };
            });
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    };
}
}),
"[project]/node_modules/cohere-ai/core/stream/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Stream = void 0;
var Stream_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/stream/Stream.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Stream", {
    enumerable: true,
    get: function() {
        return Stream_1.Stream;
    }
});
}),
"[project]/node_modules/cohere-ai/core/url/encodePathParam.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodePathParam = encodePathParam;
function encodePathParam(param) {
    if (param === null) {
        return "null";
    }
    const typeofParam = typeof param;
    switch(typeofParam){
        case "undefined":
            return "undefined";
        case "string":
        case "number":
        case "boolean":
            break;
        default:
            param = String(param);
            break;
    }
    return encodeURIComponent(param);
}
}),
"[project]/node_modules/cohere-ai/core/url/join.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.join = join;
function join(base, ...segments) {
    if (!base) {
        return "";
    }
    if (segments.length === 0) {
        return base;
    }
    if (base.includes("://")) {
        let url;
        try {
            url = new URL(base);
        } catch (_a) {
            return joinPath(base, ...segments);
        }
        const lastSegment = segments[segments.length - 1];
        const shouldPreserveTrailingSlash = lastSegment === null || lastSegment === void 0 ? void 0 : lastSegment.endsWith("/");
        for (const segment of segments){
            const cleanSegment = trimSlashes(segment);
            if (cleanSegment) {
                url.pathname = joinPathSegments(url.pathname, cleanSegment);
            }
        }
        if (shouldPreserveTrailingSlash && !url.pathname.endsWith("/")) {
            url.pathname += "/";
        }
        return url.toString();
    }
    return joinPath(base, ...segments);
}
function joinPath(base, ...segments) {
    if (segments.length === 0) {
        return base;
    }
    let result = base;
    const lastSegment = segments[segments.length - 1];
    const shouldPreserveTrailingSlash = lastSegment === null || lastSegment === void 0 ? void 0 : lastSegment.endsWith("/");
    for (const segment of segments){
        const cleanSegment = trimSlashes(segment);
        if (cleanSegment) {
            result = joinPathSegments(result, cleanSegment);
        }
    }
    if (shouldPreserveTrailingSlash && !result.endsWith("/")) {
        result += "/";
    }
    return result;
}
function joinPathSegments(left, right) {
    if (left.endsWith("/")) {
        return left + right;
    }
    return `${left}/${right}`;
}
function trimSlashes(str) {
    if (!str) return str;
    let start = 0;
    let end = str.length;
    if (str.startsWith("/")) start = 1;
    if (str.endsWith("/")) end = str.length - 1;
    return start === 0 && end === str.length ? str : str.slice(start, end);
}
}),
"[project]/node_modules/cohere-ai/core/url/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toQueryString = exports.join = exports.encodePathParam = void 0;
var encodePathParam_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/url/encodePathParam.js [app-route] (ecmascript)");
Object.defineProperty(exports, "encodePathParam", {
    enumerable: true,
    get: function() {
        return encodePathParam_1.encodePathParam;
    }
});
var join_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/url/join.js [app-route] (ecmascript)");
Object.defineProperty(exports, "join", {
    enumerable: true,
    get: function() {
        return join_1.join;
    }
});
var qs_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/core/url/qs.js [app-route] (ecmascript)");
Object.defineProperty(exports, "toQueryString", {
    enumerable: true,
    get: function() {
        return qs_1.toQueryString;
    }
});
}),
"[project]/node_modules/cohere-ai/core/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.url = exports.serialization = exports.logging = exports.file = void 0;
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/auth/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/base64.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/fetcher/index.js [app-route] (ecmascript)"), exports);
exports.file = __importStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/file/index.js [app-route] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/form-data-utils/index.js [app-route] (ecmascript)"), exports);
exports.logging = __importStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/logging/index.js [app-route] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/runtime/index.js [app-route] (ecmascript)"), exports);
exports.serialization = __importStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/schemas/index.js [app-route] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/stream/index.js [app-route] (ecmascript)"), exports);
exports.url = __importStar(__turbopack_context__.r("[project]/node_modules/cohere-ai/core/url/index.js [app-route] (ecmascript)"));
}),
"[project]/node_modules/cohere-ai/core/streaming-fetcher/streaming-utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// from https://raw.githubusercontent.com/openai/openai-node/6f72e7ad3e4e151c9334f4449d1c3555255c2793/src/streaming.ts
var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
var __await = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LineDecoder = exports.StreamUtils = void 0;
exports._iterSSEMessages = _iterSSEMessages;
exports._decodeChunks = _decodeChunks;
exports.readableStreamAsyncIterable = readableStreamAsyncIterable;
const errors_1 = __turbopack_context__.r("[project]/node_modules/cohere-ai/errors/index.js [app-route] (ecmascript)");
class StreamUtils {
    constructor(iterator, controller){
        this.iterator = iterator;
        this.controller = controller;
    }
    static fromSSEResponse(response, controller) {
        let consumed = false;
        function iterator() {
            return __asyncGenerator(this, arguments, function* iterator_1() {
                var _a, e_1, _b, _c;
                if (consumed) {
                    throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');
                }
                consumed = true;
                let done = false;
                try {
                    try {
                        for(var _d = true, _e = __asyncValues(_iterSSEMessages(response, controller)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true){
                            _c = _f.value;
                            _d = false;
                            const sse = _c;
                            if (done) continue;
                            if (sse.data.startsWith('[DONE]')) {
                                done = true;
                                continue;
                            }
                            if (sse.event === null) {
                                let data;
                                try {
                                    data = JSON.parse(sse.data);
                                } catch (e) {
                                    console.error(`Could not parse message into JSON:`, sse.data);
                                    console.error(`From chunk:`, sse.raw);
                                    throw e;
                                }
                                if (data && data.error) {
                                    throw new errors_1.CohereError({
                                        message: `Error: ${data.error}`
                                    });
                                }
                                yield yield __await(data);
                            } else {
                                let data;
                                try {
                                    data = JSON.parse(sse.data);
                                } catch (e) {
                                    console.error(`Could not parse message into JSON:`, sse.data);
                                    console.error(`From chunk:`, sse.raw);
                                    throw e;
                                }
                                // TODO: Is this where the error should be thrown?
                                if (sse.event == 'error') {
                                    throw new errors_1.CohereError({
                                        message: `Error: ${data.message}, ${data.error}`
                                    });
                                }
                                yield yield __await({
                                    event: sse.event,
                                    data: data
                                });
                            }
                        }
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally{
                        try {
                            if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                        } finally{
                            if (e_1) throw e_1.error;
                        }
                    }
                    done = true;
                } catch (e) {
                    // If the user calls `stream.controller.abort()`, we should exit without throwing.
                    if (e instanceof Error && e.name === 'AbortError') return yield __await(void 0);
                    throw e;
                } finally{
                    // If the user `break`s, abort the ongoing request.
                    if (!done) controller === null || controller === void 0 ? void 0 : controller.abort();
                }
            });
        }
        return new StreamUtils(iterator, controller);
    }
    /**
     * Generates a Stream from a newline-separated ReadableStream
     * where each item is a JSON value.
     */ static fromReadableStream(readableStream, controller) {
        let consumed = false;
        function iterLines() {
            return __asyncGenerator(this, arguments, function* iterLines_1() {
                var _a, e_2, _b, _c;
                const lineDecoder = new LineDecoder();
                const iter = readableStreamAsyncIterable(readableStream);
                try {
                    for(var _d = true, iter_1 = __asyncValues(iter), iter_1_1; iter_1_1 = yield __await(iter_1.next()), _a = iter_1_1.done, !_a; _d = true){
                        _c = iter_1_1.value;
                        _d = false;
                        const chunk = _c;
                        for (const line of lineDecoder.decode(chunk)){
                            yield yield __await(line);
                        }
                    }
                } catch (e_2_1) {
                    e_2 = {
                        error: e_2_1
                    };
                } finally{
                    try {
                        if (!_d && !_a && (_b = iter_1.return)) yield __await(_b.call(iter_1));
                    } finally{
                        if (e_2) throw e_2.error;
                    }
                }
                for (const line of lineDecoder.flush()){
                    yield yield __await(line);
                }
            });
        }
        function iterator() {
            return __asyncGenerator(this, arguments, function* iterator_2() {
                var _a, e_3, _b, _c;
                if (consumed) {
                    throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');
                }
                consumed = true;
                let done = false;
                try {
                    try {
                        for(var _d = true, _e = __asyncValues(iterLines()), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true){
                            _c = _f.value;
                            _d = false;
                            const line = _c;
                            if (done) continue;
                            if (line) yield yield __await(JSON.parse(line));
                        }
                    } catch (e_3_1) {
                        e_3 = {
                            error: e_3_1
                        };
                    } finally{
                        try {
                            if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                        } finally{
                            if (e_3) throw e_3.error;
                        }
                    }
                    done = true;
                } catch (e) {
                    // If the user calls `stream.controller.abort()`, we should exit without throwing.
                    if (e instanceof Error && e.name === 'AbortError') return yield __await(void 0);
                    throw e;
                } finally{
                    // If the user `break`s, abort the ongoing request.
                    if (!done) controller === null || controller === void 0 ? void 0 : controller.abort();
                }
            });
        }
        return new StreamUtils(iterator, controller);
    }
    [Symbol.asyncIterator]() {
        return this.iterator();
    }
    /**
     * Splits the stream into two streams which can be
     * independently read from at different speeds.
     */ tee() {
        const left = [];
        const right = [];
        const iterator = this.iterator();
        const teeIterator = (queue)=>{
            return {
                next: ()=>{
                    if (queue.length === 0) {
                        const result = iterator.next();
                        left.push(result);
                        right.push(result);
                    }
                    return queue.shift();
                }
            };
        };
        return [
            new StreamUtils(()=>teeIterator(left), this.controller),
            new StreamUtils(()=>teeIterator(right), this.controller)
        ];
    }
    /**
     * Converts this stream to a newline-separated ReadableStream of
     * JSON stringified values in the stream
     * which can be turned back into a Stream with `Stream.fromReadableStream()`.
     */ toReadableStream() {
        const self = this;
        let iter;
        const encoder = new TextEncoder();
        return new ReadableStream({
            start () {
                return __awaiter(this, void 0, void 0, function*() {
                    iter = self[Symbol.asyncIterator]();
                });
            },
            pull (ctrl) {
                return __awaiter(this, void 0, void 0, function*() {
                    try {
                        const { value, done } = yield iter.next();
                        if (done) return ctrl.close();
                        const bytes = encoder.encode(JSON.stringify(value) + '\n');
                        ctrl.enqueue(bytes);
                    } catch (err) {
                        ctrl.error(err);
                    }
                });
            },
            cancel () {
                return __awaiter(this, void 0, void 0, function*() {
                    var _a;
                    yield (_a = iter.return) === null || _a === void 0 ? void 0 : _a.call(iter);
                });
            }
        });
    }
}
exports.StreamUtils = StreamUtils;
function _iterSSEMessages(response, controller) {
    return __asyncGenerator(this, arguments, function* _iterSSEMessages_1() {
        var _a, e_4, _b, _c;
        if (!response.body) {
            controller === null || controller === void 0 ? void 0 : controller.abort();
            throw new errors_1.CohereError({
                message: `Attempted to iterate over a response with no body`
            });
        }
        const sseDecoder = new SSEDecoder();
        const lineDecoder = new LineDecoder();
        const iter = readableStreamAsyncIterable(response.body);
        try {
            for(var _d = true, _e = __asyncValues(iterSSEChunks(iter)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true){
                _c = _f.value;
                _d = false;
                const sseChunk = _c;
                for (const line of lineDecoder.decode(sseChunk)){
                    const sse = sseDecoder.decode(line);
                    if (sse) yield yield __await(sse);
                }
            }
        } catch (e_4_1) {
            e_4 = {
                error: e_4_1
            };
        } finally{
            try {
                if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
            } finally{
                if (e_4) throw e_4.error;
            }
        }
        for (const line of lineDecoder.flush()){
            const sse = sseDecoder.decode(line);
            if (sse) yield yield __await(sse);
        }
    });
}
/**
 * Given an async iterable iterator, iterates over it and yields full
 * SSE chunks, i.e. yields when a double new-line is encountered.
 */ function iterSSEChunks(iterator) {
    return __asyncGenerator(this, arguments, function* iterSSEChunks_1() {
        var _a, e_5, _b, _c;
        let data = new Uint8Array();
        try {
            for(var _d = true, iterator_3 = __asyncValues(iterator), iterator_3_1; iterator_3_1 = yield __await(iterator_3.next()), _a = iterator_3_1.done, !_a; _d = true){
                _c = iterator_3_1.value;
                _d = false;
                const chunk = _c;
                if (chunk == null) {
                    continue;
                }
                const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === 'string' ? new TextEncoder().encode(chunk) : chunk;
                let newData = new Uint8Array(data.length + binaryChunk.length);
                newData.set(data);
                newData.set(binaryChunk, data.length);
                data = newData;
                let patternIndex;
                while((patternIndex = findDoubleNewlineIndex(data)) !== -1){
                    yield yield __await(data.slice(0, patternIndex));
                    data = data.slice(patternIndex);
                }
            }
        } catch (e_5_1) {
            e_5 = {
                error: e_5_1
            };
        } finally{
            try {
                if (!_d && !_a && (_b = iterator_3.return)) yield __await(_b.call(iterator_3));
            } finally{
                if (e_5) throw e_5.error;
            }
        }
        if (data.length > 0) {
            yield yield __await(data);
        }
    });
}
function findDoubleNewlineIndex(buffer) {
    // This function searches the buffer for the end patterns (\r\r, \n\n, \r\n\r\n)
    // and returns the index right after the first occurrence of any pattern,
    // or -1 if none of the patterns are found.
    const newline = 0x0a; // \n
    const carriage = 0x0d; // \r
    for(let i = 0; i < buffer.length - 2; i++){
        if (buffer[i] === newline && buffer[i + 1] === newline) {
            // \n\n
            return i + 2;
        }
        if (buffer[i] === carriage && buffer[i + 1] === carriage) {
            // \r\r
            return i + 2;
        }
        if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
            // \r\n\r\n
            return i + 4;
        }
    }
    return -1;
}
class SSEDecoder {
    constructor(){
        this.event = null;
        this.data = [];
        this.chunks = [];
    }
    decode(line) {
        if (line.endsWith('\r')) {
            line = line.substring(0, line.length - 1);
        }
        if (!line) {
            // empty line and we didn't previously encounter any messages
            if (!this.event && !this.data.length) return null;
            const sse = {
                event: this.event,
                data: this.data.join('\n'),
                raw: this.chunks
            };
            this.event = null;
            this.data = [];
            this.chunks = [];
            return sse;
        }
        this.chunks.push(line);
        if (line.startsWith(':')) {
            return null;
        }
        let [fieldname, _, value] = partition(line, ':');
        if (value.startsWith(' ')) {
            value = value.substring(1);
        }
        if (fieldname === 'event') {
            this.event = value;
        } else if (fieldname === 'data') {
            this.data.push(value);
        }
        return null;
    }
}
/**
 * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally
 * reading lines from text.
 *
 * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258
 */ class LineDecoder {
    constructor(){
        this.buffer = [];
        this.trailingCR = false;
    }
    decode(chunk) {
        let text = this.decodeText(chunk);
        if (this.trailingCR) {
            text = '\r' + text;
            this.trailingCR = false;
        }
        if (text.endsWith('\r')) {
            this.trailingCR = true;
            text = text.slice(0, -1);
        }
        if (!text) {
            return [];
        }
        const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');
        let lines = text.split(LineDecoder.NEWLINE_REGEXP);
        // if there is a trailing new line then the last entry will be an empty
        // string which we don't care about
        if (trailingNewline) {
            lines.pop();
        }
        if (lines.length === 1 && !trailingNewline) {
            this.buffer.push(lines[0]);
            return [];
        }
        if (this.buffer.length > 0) {
            lines = [
                this.buffer.join('') + lines[0],
                ...lines.slice(1)
            ];
            this.buffer = [];
        }
        if (!trailingNewline) {
            this.buffer = [
                lines.pop() || ''
            ];
        }
        return lines;
    }
    decodeText(bytes) {
        var _a;
        if (bytes == null) return '';
        if (typeof bytes === 'string') return bytes;
        // Node:
        if (typeof Buffer !== 'undefined') {
            if (bytes instanceof Buffer) {
                return bytes.toString();
            }
            if (bytes instanceof Uint8Array) {
                return Buffer.from(bytes).toString();
            }
            throw new errors_1.CohereError({
                message: `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`
            });
        }
        // Browser
        if (typeof TextDecoder !== 'undefined') {
            if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
                (_a = this.textDecoder) !== null && _a !== void 0 ? _a : this.textDecoder = new TextDecoder('utf8');
                return this.textDecoder.decode(bytes);
            }
            throw new errors_1.CohereError({
                message: `Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`
            });
        }
        throw new errors_1.CohereError({
            message: `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`
        });
    }
    flush() {
        if (!this.buffer.length && !this.trailingCR) {
            return [];
        }
        const lines = [
            this.buffer.join('')
        ];
        this.buffer = [];
        this.trailingCR = false;
        return lines;
    }
}
exports.LineDecoder = LineDecoder;
// prettier-ignore
LineDecoder.NEWLINE_CHARS = new Set([
    '\n',
    '\r'
]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
/** This is an internal helper function that's just used for testing */ function _decodeChunks(chunks) {
    const decoder = new LineDecoder();
    const lines = [];
    for (const chunk of chunks){
        lines.push(...decoder.decode(chunk));
    }
    return lines;
}
function partition(str, delimiter) {
    const index = str.indexOf(delimiter);
    if (index !== -1) {
        return [
            str.substring(0, index),
            delimiter,
            str.substring(index + delimiter.length)
        ];
    }
    return [
        str,
        '',
        ''
    ];
}
/**
 * Most browsers don't yet have async iterable support for ReadableStream,
 * and Node has a very different way of reading bytes from its "ReadableStream".
 *
 * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490
 */ function readableStreamAsyncIterable(stream) {
    if (stream[Symbol.asyncIterator]) return stream;
    const reader = stream.getReader();
    return {
        next () {
            return __awaiter(this, void 0, void 0, function*() {
                try {
                    const result = yield reader.read();
                    if (result === null || result === void 0 ? void 0 : result.done) reader.releaseLock(); // release lock when stream becomes closed
                    return result;
                } catch (e) {
                    reader.releaseLock(); // release lock when stream becomes errored
                    throw e;
                }
            });
        },
        return () {
            return __awaiter(this, void 0, void 0, function*() {
                const cancelPromise = reader.cancel();
                reader.releaseLock();
                yield cancelPromise;
                return {
                    done: true,
                    value: undefined
                };
            });
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    };
}
}),
"[project]/node_modules/cohere-ai/core/headers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeHeaders = mergeHeaders;
exports.mergeOnlyDefinedHeaders = mergeOnlyDefinedHeaders;
function mergeHeaders(...headersArray) {
    const result = {};
    for (const [key, value] of headersArray.filter((headers)=>headers != null).flatMap((headers)=>Object.entries(headers))){
        const insensitiveKey = key.toLowerCase();
        if (value != null) {
            result[insensitiveKey] = value;
        } else if (insensitiveKey in result) {
            delete result[insensitiveKey];
        }
    }
    return result;
}
function mergeOnlyDefinedHeaders(...headersArray) {
    const result = {};
    for (const [key, value] of headersArray.filter((headers)=>headers != null).flatMap((headers)=>Object.entries(headers))){
        const insensitiveKey = key.toLowerCase();
        if (value != null) {
            result[insensitiveKey] = value;
        }
    }
    return result;
}
}),
];

//# sourceMappingURL=node_modules_cohere-ai_core_2879acdb._.js.map